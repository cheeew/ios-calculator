{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/mathjs/lib/utils/object.js","webpack:///./node_modules/mathjs/lib/utils/bignumber/isBigNumber.js","webpack:///./node_modules/mathjs/lib/utils/number.js","webpack:///./src/app.js","webpack:///./node_modules/mathjs/core.js","webpack:///./node_modules/mathjs/lib/core/core.js","webpack:///./node_modules/mathjs/lib/utils/polyfills.js","webpack:///./node_modules/mathjs/lib/core/typed.js","webpack:///./node_modules/typed-function/typed-function.js","webpack:///./node_modules/mathjs/lib/utils/collection/isMatrix.js","webpack:///./node_modules/mathjs/lib/utils/emitter.js","webpack:///./node_modules/tiny-emitter/index.js","webpack:///./node_modules/mathjs/lib/core/function/import.js","webpack:///./node_modules/mathjs/lib/error/ArgumentsError.js","webpack:///./node_modules/mathjs/lib/core/function/config.js","webpack:///./node_modules/mathjs/lib/function/string/format.js","webpack:///./node_modules/mathjs/lib/utils/string.js","webpack:///./node_modules/mathjs/lib/utils/bignumber/formatter.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_typeof","iterator","obj","constructor","isBigNumber","clone","x","type","undefined","Array","isArray","map","Date","valueOf","RegExp","TypeError","callback","extend","a","b","prop","deepExtend","deepEqual","len","length","canDefineProperty","e","lazy","fn","_uninitialized","_value","set","configurable","traverse","path","names","split","isFactory","factory","objectUtils","zeros","arr","push","isNumber","isInteger","isFinite","Math","round","sign","format","options","Infinity","isNaN","notation","precision","toFixed","toExponential","toEngineering","exponential","lower","upper","fixedOptions","lowerExp","log","LN10","upperExp","console","warn","JSON","stringify","toPrecision","replace","digits","arguments","Error","splitNumber","match","String","toLowerCase","SyntaxError","exponent","parseFloat","dot","indexOf","coefficients","parseInt","rounded","roundDigits","newExp","concat","significandsDiff","abs","expDiff","decimalIdx","decimals","slice","join","decimalVal","str","toString","splitValue","pp","splice","first","shift","unshift","pop","DBL_EPSILON","Number","EPSILON","nearlyEqual","y","epsilon","diff","max","math","core","import","numberButtons","document","querySelectorAll","operatorButtons","calcDisplay","querySelector","clearButton","plusMinus","percentage","equals","currentValue","prevCurrent","lastValue","result","firstOp","selectedOperator","displayEntry","_this","this","innerHTML","textContent","includes","button","className","classList","remove","number","num","numberWithCommas","forEach","isActive","hasNoComma","operators","+","-","/","*","pemdasLogic","dataset","symbol","add","pemdasResult","chooseOperator","_this2","id","ans","toLocaleString","maximumSignificantDigits","addEventListener","body","typedFactory","emitter","importFactory","configFactory","factories","instances","mixin","expression","transform","mathWithTransform","typed","_config","matrix","predictable","randomSeed","load","index","instance","config","typedFunction","isMatrix","_createTyped","isComplex","Complex","isFraction","Fraction","isUnit","isString","isDenseMatrix","isSparseMatrix","isRange","isIndex","isBoolean","isResultSet","isHelp","isFunction","isDate","isRegExp","isObject","isNull","isUndefined","isAccessorNode","isNode","isArrayNode","isAssignmentNode","isBlockNode","isConditionalNode","isConstantNode","isFunctionAssignmentNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","isParenthesisNode","isRangeNode","isSymbolNode","isChain","types","test","conversions","from","to","convert","BigNumber","toNumber","err","array","DenseMatrix","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","ok","notOk","undef","_types","anyType","_ignore","_conversions","ignore","findTypeByName","typeName","entry","findInArray","hint","findTypeIndex","findTypeName","stringifyParams","params","param","typeNames","getTypeName","restParam","parseParam","trim","filter","notEmpty","notIgnore","matchingConversions","matches","conversion","keys","filterConversions","exactTypes","typeIndex","conversionIndex","convertibleTypes","hasRestParam","last","hasConversions","some","compileTest","test0","test1","tests","compileTests","varIndex","initial","lastTest","args","testRestParam","getParamAtIndex","signature","getExpectedTypeNames","excludeConversions","isExactType","mergeExpectedParams","signatures","entries","uniq","flatMap","getLowestTypeIndex","min","getLowestConversionIndex","compareParams","param1","param2","compareSignatures","signature1","signature2","compileArgConversion","conversion0","conversion1","arg","splitParams","ignoreConversionTypes","_splitParams","typeGroups","filteredTypes","typeGroup","splittedParams","createTypedFunction","signaturesMap","parsedSignatures","parsedParam","isInvalidParam","parseSignature","notNull","parsedSignature","conflictingSignature","ii","typesNames1","typesNames2","hasOverlap","len1","len2","restParam1","restParam2","hasConflictingParams","sort","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fns","fnConvert","compiledConversions","apply","fnPreprocess","offset","compileArgsPreprocessing","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","generic","expected","_name","matchingSignatures","nextMatchingDefs","actualType","data","category","actual","lengths","maxLength","expectedLength","createError","arg0","arg1","createSignaturesMap","start","end","contains","item","array1","array2","getName","extractSignatures","validateUnique","_signature","_fn","string, Object","...Function","string, ...Function","find","addType","beforeObjectTest","addConversion","Emitter","on","off","once","emit","E","ctx","self","listener","_","evtArr","evts","liveEvents","ArgumentsError","_import","wrap","wrapper","_wrap","isTypedFunction","override","_importTransform","silent","allowedInExpressions","_deleteTransform","_importFactory","existingTransform","namespace","existing","resolver","factoryAllowedInExpressions","isSupportedType","unsafe","docs","error","json","chain","mathImport","count","message","stack","isArgumentsError","validateOption","values","findIndex","MATRIX","NUMBER","prev","curr","changes","string","any","any, Object | function | number","toTex","formatNumber","formatBigNumber","endsWith","text","search","substring","looksLikeFraction","fraction","formatArray","syntax","escaped","charAt","escape","gt","isZero","exp","logarithm","gte","lt","toSignificantDigits"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar isBigNumber = require('./bignumber/isBigNumber');\n\n/**\n * Clone an object\n *\n *     clone(x)\n *\n * Can clone any primitive type, array, and object.\n * If x has a function clone, this function will be invoked to clone the object.\n *\n * @param {*} x\n * @return {*} clone\n */\nexports.clone = function clone(x) {\n  var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);\n\n  // immutable primitive types\n  if (type === 'number' || type === 'string' || type === 'boolean' || x === null || x === undefined) {\n    return x;\n  }\n\n  // use clone function of the object when available\n  if (typeof x.clone === 'function') {\n    return x.clone();\n  }\n\n  // array\n  if (Array.isArray(x)) {\n    return x.map(function (value) {\n      return clone(value);\n    });\n  }\n\n  if (x instanceof Date) return new Date(x.valueOf());\n  if (isBigNumber(x)) return x; // bignumbers are immutable\n  if (x instanceof RegExp) throw new TypeError('Cannot clone ' + x); // TODO: clone a RegExp\n\n  // object\n  return exports.map(x, clone);\n};\n\n/**\n * Apply map to all properties of an object\n * @param {Object} object\n * @param {function} callback\n * @return {Object} Returns a copy of the object with mapped properties\n */\nexports.map = function (object, callback) {\n  var clone = {};\n\n  for (var key in object) {\n    if (exports.hasOwnProperty(object, key)) {\n      clone[key] = callback(object[key]);\n    }\n  }\n\n  return clone;\n};\n\n/**\n * Extend object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n */\nexports.extend = function (a, b) {\n  for (var prop in b) {\n    if (exports.hasOwnProperty(b, prop)) {\n      a[prop] = b[prop];\n    }\n  }\n  return a;\n};\n\n/**\n * Deep extend an object a with the properties of object b\n * @param {Object} a\n * @param {Object} b\n * @returns {Object}\n */\nexports.deepExtend = function deepExtend(a, b) {\n  // TODO: add support for Arrays to deepExtend\n  if (Array.isArray(b)) {\n    throw new TypeError('Arrays are not supported by deepExtend');\n  }\n\n  for (var prop in b) {\n    if (exports.hasOwnProperty(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n        if (a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop]);\n        } else {\n          a[prop] = b[prop];\n        }\n      } else if (Array.isArray(b[prop])) {\n        throw new TypeError('Arrays are not supported by deepExtend');\n      } else {\n        a[prop] = b[prop];\n      }\n    }\n  }\n  return a;\n};\n\n/**\n * Deep test equality of all fields in two pairs of arrays or objects.\n * @param {Array | Object} a\n * @param {Array | Object} b\n * @returns {boolean}\n */\nexports.deepEqual = function deepEqual(a, b) {\n  var prop = void 0,\n      i = void 0,\n      len = void 0;\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0, len = a.length; i < len; i++) {\n      if (!exports.deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  } else if (a instanceof Object) {\n    if (Array.isArray(b) || !(b instanceof Object)) {\n      return false;\n    }\n\n    for (prop in a) {\n      // noinspection JSUnfilteredForInLoop\n      if (!exports.deepEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n    for (prop in b) {\n      // noinspection JSUnfilteredForInLoop\n      if (!exports.deepEqual(a[prop], b[prop])) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return a === b;\n  }\n};\n\n/**\n * Test whether the current JavaScript engine supports Object.defineProperty\n * @returns {boolean} returns true if supported\n */\nexports.canDefineProperty = function () {\n  // test needed for broken IE8 implementation\n  try {\n    if (Object.defineProperty) {\n      Object.defineProperty({}, 'x', { get: function get() {} });\n      return true;\n    }\n  } catch (e) {}\n\n  return false;\n};\n\n/**\n * Attach a lazy loading property to a constant.\n * The given function `fn` is called once when the property is first requested.\n * On older browsers (<IE8), the function will fall back to direct evaluation\n * of the properties value.\n * @param {Object} object   Object where to add the property\n * @param {string} prop     Property name\n * @param {Function} fn     Function returning the property value. Called\n *                          without arguments.\n */\nexports.lazy = function (object, prop, fn) {\n  if (exports.canDefineProperty()) {\n    var _uninitialized = true;\n    var _value = void 0;\n    Object.defineProperty(object, prop, {\n      get: function get() {\n        if (_uninitialized) {\n          _value = fn();\n          _uninitialized = false;\n        }\n        return _value;\n      },\n\n      set: function set(value) {\n        _value = value;\n        _uninitialized = false;\n      },\n\n      configurable: true,\n      enumerable: true\n    });\n  } else {\n    // fall back to immediate evaluation\n    object[prop] = fn();\n  }\n};\n\n/**\n * Traverse a path into an object.\n * When a namespace is missing, it will be created\n * @param {Object} object\n * @param {string} path   A dot separated string like 'name.space'\n * @return {Object} Returns the object at the end of the path\n */\nexports.traverse = function (object, path) {\n  var obj = object;\n\n  if (path) {\n    var names = path.split('.');\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      if (!(name in obj)) {\n        obj[name] = {};\n      }\n      obj = obj[name];\n    }\n  }\n\n  return obj;\n};\n\n/**\n * A safe hasOwnProperty\n * @param {Object} object\n * @param {string} property\n */\nexports.hasOwnProperty = function (object, property) {\n  return object && Object.hasOwnProperty.call(object, property);\n};\n\n/**\n * Test whether an object is a factory. a factory has fields:\n *\n * - factory: function (type: Object, config: Object, load: function, typed: function [, math: Object])   (required)\n * - name: string (optional)\n * - path: string    A dot separated path (optional)\n * - math: boolean   If true (false by default), the math namespace is passed\n *                   as fifth argument of the factory function\n *\n * @param {*} object\n * @returns {boolean}\n */\nexports.isFactory = function (object) {\n  return object && typeof object.factory === 'function';\n};","'use strict';\n/**\n * Test whether a value is a BigNumber\n * @param {*} x\n * @return {boolean}\n */\n\nmodule.exports = function isBigNumber(x) {\n  return x && x.constructor.prototype.isBigNumber || false;\n};","'use strict';\n\nvar objectUtils = require('./object');\n\n/**\n * @typedef {{sign: '+' | '-' | '', coefficients: number[], exponent: number}} SplitValue\n */\n\n/**\n * Test whether value is a number\n * @param {*} value\n * @return {boolean} isNumber\n */\nexports.isNumber = function (value) {\n  return typeof value === 'number';\n};\n\n/**\n * Check if a number is integer\n * @param {number | boolean} value\n * @return {boolean} isInteger\n */\nexports.isInteger = function (value) {\n  if (typeof value === 'boolean') {\n    return true;\n  }\n\n  return isFinite(value) ? value === Math.round(value) : false;\n  // Note: we use ==, not ===, as we can have Booleans as well\n};\n\n/**\n * Calculate the sign of a number\n * @param {number} x\n * @returns {*}\n */\nexports.sign = Math.sign || function (x) {\n  if (x > 0) {\n    return 1;\n  } else if (x < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\n/**\n * Convert a number to a formatted string representation.\n *\n * Syntax:\n *\n *    format(value)\n *    format(value, options)\n *    format(value, precision)\n *    format(value, fn)\n *\n * Where:\n *\n *    {number} value   The value to be formatted\n *    {Object} options An object with formatting options. Available options:\n *                     {string} notation\n *                         Number notation. Choose from:\n *                         'fixed'          Always use regular number notation.\n *                                          For example '123.40' and '14000000'\n *                         'exponential'    Always use exponential notation.\n *                                          For example '1.234e+2' and '1.4e+7'\n *                         'engineering'    Always use engineering notation.\n *                                          For example '123.4e+0' and '14.0e+6'\n *                         'auto' (default) Regular number notation for numbers\n *                                          having an absolute value between\n *                                          `lowerExp` and `upperExp` bounds, and\n *                                          uses exponential notation elsewhere.\n *                                          Lower bound is included, upper bound\n *                                          is excluded.\n *                                          For example '123.4' and '1.4e7'.\n *                     {number} precision   A number between 0 and 16 to round\n *                                          the digits of the number.\n *                                          In case of notations 'exponential',\n *                                          'engineering', and 'auto',\n *                                          `precision` defines the total\n *                                          number of significant digits returned.\n *                                          In case of notation 'fixed',\n *                                          `precision` defines the number of\n *                                          significant digits after the decimal\n *                                          point.\n *                                          `precision` is undefined by default,\n *                                          not rounding any digits.\n *                     {number} lowerExp    Exponent determining the lower boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `-3`.\n *                     {number} upperExp    Exponent determining the upper boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `5`.\n *    {Function} fn    A custom formatting function. Can be used to override the\n *                     built-in notations. Function `fn` is called with `value` as\n *                     parameter and must return a string. Is useful for example to\n *                     format all values inside a matrix in a particular way.\n *\n * Examples:\n *\n *    format(6.4)                                        // '6.4'\n *    format(1240000)                                    // '1.24e6'\n *    format(1/3)                                        // '0.3333333333333333'\n *    format(1/3, 3)                                     // '0.333'\n *    format(21385, 2)                                   // '21000'\n *    format(12.071, {notation: 'fixed'})                // '12'\n *    format(2.3,    {notation: 'fixed', precision: 2})  // '2.30'\n *    format(52.8,   {notation: 'exponential'})          // '5.28e+1'\n *    format(12345678, {notation: 'engineering'})        // '12.345678e+6'\n *\n * @param {number} value\n * @param {Object | Function | number} [options]\n * @return {string} str The formatted value\n */\nexports.format = function (value, options) {\n  if (typeof options === 'function') {\n    // handle format(value, fn)\n    return options(value);\n  }\n\n  // handle special cases\n  if (value === Infinity) {\n    return 'Infinity';\n  } else if (value === -Infinity) {\n    return '-Infinity';\n  } else if (isNaN(value)) {\n    return 'NaN';\n  }\n\n  // default values for options\n  var notation = 'auto';\n  var precision = void 0;\n\n  if (options) {\n    // determine notation from options\n    if (options.notation) {\n      notation = options.notation;\n    }\n\n    // determine precision from options\n    if (exports.isNumber(options)) {\n      precision = options;\n    } else if (options.precision) {\n      precision = options.precision;\n    }\n  }\n\n  // handle the various notations\n  switch (notation) {\n    case 'fixed':\n      return exports.toFixed(value, precision);\n\n    case 'exponential':\n      return exports.toExponential(value, precision);\n\n    case 'engineering':\n      return exports.toEngineering(value, precision);\n\n    case 'auto':\n      // TODO: clean up some day. Deprecated since: 2018-01-24\n      // @deprecated upper and lower are replaced with upperExp and lowerExp since v4.0.0\n      if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {\n        var fixedOptions = objectUtils.map(options, function (x) {\n          return x;\n        });\n        fixedOptions.exponential = undefined;\n        if (options.exponential.lower !== undefined) {\n          fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);\n        }\n        if (options.exponential.upper !== undefined) {\n          fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);\n        }\n\n        console.warn('Deprecation warning: Formatting options exponential.lower and exponential.upper ' + '(minimum and maximum value) ' + 'are replaced with exponential.lowerExp and exponential.upperExp ' + '(minimum and maximum exponent) since version 4.0.0. ' + 'Replace ' + JSON.stringify(options) + ' with ' + JSON.stringify(fixedOptions));\n\n        return exports.toPrecision(value, precision, fixedOptions);\n      }\n\n      return exports.toPrecision(value, precision, options && options)\n\n      // remove trailing zeros after the decimal point\n      .replace(/((\\.\\d*?)(0+))($|e)/, function () {\n        var digits = arguments[2];\n        var e = arguments[4];\n        return digits !== '.' ? digits + e : e;\n      });\n\n    default:\n      throw new Error('Unknown notation \"' + notation + '\". ' + 'Choose \"auto\", \"exponential\", or \"fixed\".');\n  }\n};\n\n/**\n * Split a number into sign, coefficients, and exponent\n * @param {number | string} value\n * @return {SplitValue}\n *              Returns an object containing sign, coefficients, and exponent\n */\nexports.splitNumber = function (value) {\n  // parse the input value\n  var match = String(value).toLowerCase().match(/^0*?(-?)(\\d+\\.?\\d*)(e([+-]?\\d+))?$/);\n  if (!match) {\n    throw new SyntaxError('Invalid number ' + value);\n  }\n\n  var sign = match[1];\n  var digits = match[2];\n  var exponent = parseFloat(match[4] || '0');\n\n  var dot = digits.indexOf('.');\n  exponent += dot !== -1 ? dot - 1 : digits.length - 1;\n\n  var coefficients = digits.replace('.', '') // remove the dot (must be removed before removing leading zeros)\n  .replace(/^0*/, function (zeros) {\n    // remove leading zeros, add their count to the exponent\n    exponent -= zeros.length;\n    return '';\n  }).replace(/0*$/, '') // remove trailing zeros\n  .split('').map(function (d) {\n    return parseInt(d);\n  });\n\n  if (coefficients.length === 0) {\n    coefficients.push(0);\n    exponent++;\n  }\n\n  return {\n    sign: sign,\n    coefficients: coefficients,\n    exponent: exponent\n  };\n};\n\n/**\n * Format a number in engineering notation. Like '1.23e+6', '2.3e+0', '3.500e-3'\n * @param {number | string} value\n * @param {number} [precision]        Optional number of significant figures to return.\n */\nexports.toEngineering = function (value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  var rounded = exports.roundDigits(exports.splitNumber(value), precision);\n\n  var e = rounded.exponent;\n  var c = rounded.coefficients;\n\n  // find nearest lower multiple of 3 for exponent\n  var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;\n\n  if (exports.isNumber(precision)) {\n    // add zeroes to give correct sig figs\n    if (precision > c.length) c = c.concat(zeros(precision - c.length));\n  } else {\n    // concatenate coefficients with necessary zeros\n    var significandsDiff = e >= 0 ? e : Math.abs(newExp);\n\n    // add zeros if necessary (for ex: 1e+8)\n    if (c.length - 1 < significandsDiff) c = c.concat(zeros(significandsDiff - (c.length - 1)));\n  }\n\n  // find difference in exponents\n  var expDiff = Math.abs(e - newExp);\n\n  var decimalIdx = 1;\n\n  // push decimal index over by expDiff times\n  while (--expDiff >= 0) {\n    decimalIdx++;\n  } // if all coefficient values are zero after the decimal point and precision is unset, don't add a decimal value.\n  // otherwise concat with the rest of the coefficients\n  var decimals = c.slice(decimalIdx).join('');\n  var decimalVal = exports.isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? '.' + decimals : '';\n\n  var str = c.slice(0, decimalIdx).join('') + decimalVal + 'e' + (e >= 0 ? '+' : '') + newExp.toString();\n  return rounded.sign + str;\n};\n\n/**\n * Format a number with fixed notation.\n * @param {number | string} value\n * @param {number} [precision=undefined]  Optional number of decimals after the\n *                                        decimal point. null by default.\n */\nexports.toFixed = function (value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  var splitValue = exports.splitNumber(value);\n  var rounded = typeof precision === 'number' ? exports.roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;\n  var c = rounded.coefficients;\n  var p = rounded.exponent + 1; // exponent may have changed\n\n  // append zeros if needed\n  var pp = p + (precision || 0);\n  if (c.length < pp) {\n    c = c.concat(zeros(pp - c.length));\n  }\n\n  // prepend zeros if needed\n  if (p < 0) {\n    c = zeros(-p + 1).concat(c);\n    p = 1;\n  }\n\n  // insert a dot if needed\n  if (p < c.length) {\n    c.splice(p, 0, p === 0 ? '0.' : '.');\n  }\n\n  return rounded.sign + c.join('');\n};\n\n/**\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\n * @param {number | string} value\n * @param {number} [precision]  Number of digits in formatted output.\n *                              If not provided, the maximum available digits\n *                              is used.\n */\nexports.toExponential = function (value, precision) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  // round if needed, else create a clone\n  var split = exports.splitNumber(value);\n  var rounded = precision ? exports.roundDigits(split, precision) : split;\n  var c = rounded.coefficients;\n  var e = rounded.exponent;\n\n  // append zeros if needed\n  if (c.length < precision) {\n    c = c.concat(zeros(precision - c.length));\n  }\n\n  // format as `C.CCCe+EEE` or `C.CCCe-EEE`\n  var first = c.shift();\n  return rounded.sign + first + (c.length > 0 ? '.' + c.join('') : '') + 'e' + (e >= 0 ? '+' : '') + e;\n};\n\n/**\n * Format a number with a certain precision\n * @param {number | string} value\n * @param {number} [precision=undefined] Optional number of digits.\n * @param {{lowerExp: number | undefined, upperExp: number | undefined}} [options]\n *                                       By default:\n *                                         lowerExp = -3 (incl)\n *                                         upper = +5 (excl)\n * @return {string}\n */\nexports.toPrecision = function (value, precision, options) {\n  if (isNaN(value) || !isFinite(value)) {\n    return String(value);\n  }\n\n  // determine lower and upper bound for exponential notation.\n  var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;\n  var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;\n\n  var split = exports.splitNumber(value);\n  if (split.exponent < lowerExp || split.exponent >= upperExp) {\n    // exponential notation\n    return exports.toExponential(value, precision);\n  } else {\n    var rounded = precision ? exports.roundDigits(split, precision) : split;\n    var c = rounded.coefficients;\n    var e = rounded.exponent;\n\n    // append trailing zeros\n    if (c.length < precision) {\n      c = c.concat(zeros(precision - c.length));\n    }\n\n    // append trailing zeros\n    // TODO: simplify the next statement\n    c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));\n\n    // prepend zeros\n    c = zeros(-e).concat(c);\n\n    var dot = e > 0 ? e : 0;\n    if (dot < c.length - 1) {\n      c.splice(dot + 1, 0, '.');\n    }\n\n    return rounded.sign + c.join('');\n  }\n};\n\n/**\n * Round the number of digits of a number *\n * @param {SplitValue} split       A value split with .splitNumber(value)\n * @param {number} precision  A positive integer\n * @return {SplitValue}\n *              Returns an object containing sign, coefficients, and exponent\n *              with rounded digits\n */\nexports.roundDigits = function (split, precision) {\n  // create a clone\n  var rounded = {\n    sign: split.sign,\n    coefficients: split.coefficients,\n    exponent: split.exponent\n  };\n  var c = rounded.coefficients;\n\n  // prepend zeros if needed\n  while (precision <= 0) {\n    c.unshift(0);\n    rounded.exponent++;\n    precision++;\n  }\n\n  if (c.length > precision) {\n    var removed = c.splice(precision, c.length - precision);\n\n    if (removed[0] >= 5) {\n      var i = precision - 1;\n      c[i]++;\n      while (c[i] === 10) {\n        c.pop();\n        if (i === 0) {\n          c.unshift(0);\n          rounded.exponent++;\n          i++;\n        }\n        i--;\n        c[i]++;\n      }\n    }\n  }\n\n  return rounded;\n};\n\n/**\n * Create an array filled with zeros.\n * @param {number} length\n * @return {Array}\n */\nfunction zeros(length) {\n  var arr = [];\n  for (var i = 0; i < length; i++) {\n    arr.push(0);\n  }\n  return arr;\n}\n\n/**\n * Count the number of significant digits of a number.\n *\n * For example:\n *   2.34 returns 3\n *   0.0034 returns 2\n *   120.5e+30 returns 4\n *\n * @param {number} value\n * @return {number} digits   Number of significant digits\n */\nexports.digits = function (value) {\n  return value.toExponential().replace(/e.*$/, '') // remove exponential notation\n  .replace(/^0\\.?0*|\\./, '') // remove decimal point and leading zeros\n  .length;\n};\n\n/**\n * Minimum number added to one that makes the result different than one\n */\nexports.DBL_EPSILON = Number.EPSILON || 2.2204460492503130808472633361816E-16;\n\n/**\n * Compares two floating point numbers.\n * @param {number} x          First value to compare\n * @param {number} y          Second value to compare\n * @param {number} [epsilon]  The maximum relative difference between x and y\n *                            If epsilon is undefined or null, the function will\n *                            test whether x and y are exactly equal.\n * @return {boolean} whether the two numbers are nearly equal\n*/\nexports.nearlyEqual = function (x, y, epsilon) {\n  // if epsilon is null or undefined, test whether x and y are exactly equal\n  if (epsilon === null || epsilon === undefined) {\n    return x === y;\n  }\n\n  if (x === y) {\n    return true;\n  }\n\n  // NaN\n  if (isNaN(x) || isNaN(y)) {\n    return false;\n  }\n\n  // at this point x and y should be finite\n  if (isFinite(x) && isFinite(y)) {\n    // check numbers are very close, needed when comparing numbers near zero\n    var diff = Math.abs(x - y);\n    if (diff < exports.DBL_EPSILON) {\n      return true;\n    } else {\n      // use relative error\n      return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;\n    }\n  }\n\n  // Infinite and Number or negative Infinite and positive Infinite cases\n  return false;\n};","// Load lightweight mathjs\nimport core from 'mathjs/core';\nconst math = core.create();\n// Import format to resolve floating point conundrum\nmath.import(require('mathjs/lib/function/string/format'));\n\n\nconst numberButtons = [...document.querySelectorAll('.row li .number')],\noperatorButtons = [...document.querySelectorAll('.row li .operator')],\ncalcDisplay = document.querySelector('.display .value'),\nclearButton = document.querySelector('#AC'),\nplusMinus = document.querySelector('#plus-minus'),\npercentage = document.querySelector('#percentage'),\nequals = document.querySelector('#equals');\nlet currentValue = '',\nprevCurrent = '',\nlastValue = '',\nresult = '',\nfirstOp = '',\nselectedOperator = '';\n\nfunction clearLogic() {\n    calcDisplay.innerHTML = '0';\n    clearButton.innerHTML = 'AC';\n\n    // Clears everything on calculator\n    if (!currentValue && calcDisplay.innerHTML === '0') {\n        currentValue = '';\n        lastValue = '';\n        selectedOperator = '';\n        result = '';\n        prevCurrent = '';\n        \n        // Clears any active operators\n        operatorButtons.map(button => {\n            if (button.className === 'operator active') {\n                button.classList.remove('active');\n            }\n        });\n    }\n\n    // Clears everything if equals button was last button pressed\n    if(equals.className === 'operator pressed') {\n        lastValue = '';\n        currentValue = 0;\n        calcDisplay.innerHTML = currentValue;\n        selectedOperator = '';\n    }\n\n    // Allows user to clear second value w/o erasing previously entered value\n    if (selectedOperator) {\n        calcDisplay.innerHTML = '0';\n        currentValue = '';\n        \n        operatorButtons.map(button => {\n            // Re-highlights last selected operator\n            if (button.dataset.symbol === selectedOperator) {\n                button.classList.add('active');\n            }\n        });\n    } \n}\n\nfunction numberWithCommas(num) {\n    // Function to add commas\n    const number = num.toString().replace(/,/g, '');\n    return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n}\n\nfunction displayEntry() {\n    // Changes initial zero to selected number, changes AC button to display C\n    if (calcDisplay.innerHTML === '0') {\n        clearButton.innerHTML === 'AC' ? clearButton.innerHTML = 'C' : '';\n        calcDisplay.innerHTML = this.textContent;  \n\n        // keeps starting zero value for values < 1\n        this.textContent === '.' ? calcDisplay.innerHTML = \"0.\" : '';\n    }\n\n    // Limits length to 11 character\n    else if (calcDisplay.innerHTML.length === 11) return; \n\n    // Adds commas to the entry\n    else if (calcDisplay !== '0' && !calcDisplay.innerHTML.includes('.')) {\n        const number = `${calcDisplay.textContent}${this.textContent}`;\n        calcDisplay.innerHTML = numberWithCommas(number);\n    }\n\n    // In response to the presence of a decimal\n    else if (calcDisplay.innerHTML.includes('.')) {\n        // Present \"0.\" if decimal is pressed after selecting an operator\n        operatorButtons.map(button => { \n            if (button.className === \"operator active\" && this.textContent === '.') {\n                calcDisplay.innerHTML = '0.';\n                button.classList.remove('active');\n            }\n        });\n\n        // Curtails additional commas after decimal has been entered\n        if (this.innerHTML === '.') return;\n\n        //  Appends numbers onto display when decimal is present\n        calcDisplay.innerHTML = `${calcDisplay.textContent}${this.textContent}`;\n    }\n\n    // Stores previous value after having selected an operator and new number\n    operatorButtons.forEach(button => {\n        const isActive = button.className==='operator active';\n        if (isActive && this.textContent === '.') {\n            button.classList.remove('active');\n            calcDisplay.innerHTML = '0.';\n        }\n        else if (isActive) {\n            button.classList.remove('active');\n            calcDisplay.innerHTML = this.textContent;\n        }\n    });\n\n    if (equals.className.includes('pressed')) { \n        calcDisplay.innerHTML = this.textContent === '.' ? '0.' : this.textContent;\n        equals.classList.remove('pressed');\n        result = '';\n        lastValue = '';\n        prevCurrent = '';\n    }\n\n    // Stores current value displayed on calculator\n    const hasNoComma = calcDisplay.innerHTML.replace(/,/g, '');\n    currentValue = parseFloat(hasNoComma);\n}\n\nconst operators = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '/': (a, b) => a / b,\n    '*': (a, b) => a * b\n}\n\nfunction pemdasLogic() {\n    // Enables pemdas recursion\n    if(firstOp && (this.dataset.symbol === '*' || this.dataset.symbol === '/')) {\n        this.classList.add('active');\n        prevCurrent = operators[selectedOperator](prevCurrent, currentValue);\n        calcDisplay.innerHTML = prevCurrent;\n        selectedOperator = this.dataset.symbol;\n        return;\n    }\n\n    // If pemdas is in effect, multiplication & division portion will be handled first\n    // Remaining portion gets computed on lines 168 - 174\n    if (lastValue && prevCurrent && currentValue) {\n        const pemdasResult = operators[selectedOperator](prevCurrent, currentValue);\n        currentValue = pemdasResult;\n        prevCurrent = '';\n        selectedOperator = firstOp;\n        return firstOp = '';\n    }\n    \n    // Captures previously selected operator\n    firstOp = selectedOperator;\n\n    // Stores current value to prevCurrent variable if pemdas equation is in effect\n    if ((firstOp === '+' || firstOp === '-') && (this.dataset.symbol === '/' || this.dataset.symbol === '*')) {\n        console.log(this);\n        selectedOperator = this.dataset.symbol;\n        this.classList.add('active');\n        prevCurrent = currentValue;\n        currentValue = '';\n    }\n}\n\n\nfunction chooseOperator() {\n    // Removes \"active\" class from the previously selected operator\n    operatorButtons.map(button => button.className === 'operator active' && !prevCurrent ? button.classList.remove('active') : '');\n\n    // Allows user to continually calculate without needing to hit the equals button\n    if (lastValue && !result && this.id !== 'equals') {\n\n        // if pemdas equation is in order do not calculate anything\n        if (prevCurrent) return\n\n        // if pemdas equation does not exist or has already computed then perform regular calculation\n        if (!prevCurrent) {\n            this.classList.add('active');\n            prevCurrent = '';\n            const ans = operators[selectedOperator](lastValue, currentValue);\n            lastValue = parseFloat(math.format(ans, {precision: 10}));\n            selectedOperator = this.dataset.symbol;\n            currentValue = '';\n            calcDisplay.innerHTML = lastValue.toLocaleString('en', {maximumSignificantDigits: 11});\n            firstOp = '';\n        }\n    }\n\n    // Stores previous numerical value, selected operator & highlights active operator\n    if (this.id !== 'equals' && !lastValue) {\n        lastValue = currentValue;\n        selectedOperator = this.dataset.symbol;\n        this.classList.add('active');\n    }\n\n    // Allows user to continue computing additional equations after having pressed equals button\n    operatorButtons.map(button => {\n        if (result === lastValue && equals.className === 'operator pressed') {\n            this.id !== 'equals' ? this.classList.add('active') : '';\n            equals.className === 'operator pressed' ? equals.classList.remove('pressed') : '';\n            result = '';\n            selectedOperator = this.dataset.symbol;\n        }\n    });\n\n    // Removes 'pressed' id from equals if the class existed\n    equals.id === 'pressed' ? equals.classList.remove('pressed') : '';\n}\n\nfunction calculate() {\n    // Avoids duplicate pemdas calculations\n    // pemdas calculations occurs via line 139 followed by line 170\n    if(prevCurrent) return;\n\n    // Indicates button has been pressed\n    this.classList.add('pressed');\n    if(!lastValue) return;\n    \n    const ans = operators[selectedOperator](lastValue, currentValue);\n    result = parseFloat(math.format(ans, {precision: 10}));\n    calcDisplay.innerHTML = result.toLocaleString('en', {maximumSignificantDigits: 11});\n    firstOp = '';\n    selectedOperator = '';\n    const hasNoComma = result.toString().replace(/,/g, '');\n    lastValue = parseFloat(hasNoComma);\n}\n\nfunction log() {\n    console.log({ lastValue, prevCurrent, currentValue, result });\n    console.log(`firstOp: ${firstOp}, selectedOperator: ${selectedOperator}`);\n}\n\nclearButton.addEventListener('click', clearLogic);\nnumberButtons.map(button => button.addEventListener('click', displayEntry));\noperatorButtons.map(button => button.addEventListener('mouseup', pemdasLogic));\noperatorButtons.map(button => button.addEventListener('mouseup', chooseOperator));\nequals.addEventListener('click', calculate);\nplusMinus.addEventListener('click', () => {\n    calcDisplay.innerHTML *= -1;\n    currentValue = parseFloat(calcDisplay.innerHTML);\n});\npercentage.addEventListener('click', () => {\n    calcDisplay.innerHTML *= 0.01;\n    currentValue = parseFloat(calcDisplay.innerHTML);\n});\ndocument.body.addEventListener('click', log);\n","module.exports = require('./lib/core/core')\n","'use strict';\n\nrequire('./../utils/polyfills');\n\nvar isFactory = require('./../utils/object').isFactory;\nvar typedFactory = require('./typed');\nvar emitter = require('./../utils/emitter');\n\nvar importFactory = require('./function/import');\nvar configFactory = require('./function/config');\n\n/**\n * Math.js core. Creates a new, empty math.js instance\n * @param {Object} [options] Available options:\n *                            {number} epsilon\n *                              Minimum relative difference between two\n *                              compared values, used by all comparison functions.\n *                            {string} matrix\n *                              A string 'Matrix' (default) or 'Array'.\n *                            {string} number\n *                              A string 'number' (default), 'BigNumber', or 'Fraction'\n *                            {number} precision\n *                              The number of significant digits for BigNumbers.\n *                              Not applicable for Numbers.\n *                            {boolean} predictable\n *                              Predictable output type of functions. When true,\n *                              output type depends only on the input types. When\n *                              false (default), output type can vary depending\n *                              on input values. For example `math.sqrt(-4)`\n *                              returns `complex('2i')` when predictable is false, and\n *                              returns `NaN` when true.\n *                            {string} randomSeed\n *                              Random seed for seeded pseudo random number generator.\n *                              Set to null to randomly seed.\n * @returns {Object} Returns a bare-bone math.js instance containing\n *                   functions:\n *                   - `import` to add new functions\n *                   - `config` to change configuration\n *                   - `on`, `off`, `once`, `emit` for events\n */\nexports.create = function create(options) {\n  // simple test for ES5 support\n  if (typeof Object.create !== 'function') {\n    throw new Error('ES5 not supported by this JavaScript engine. ' + 'Please load the es5-shim and es5-sham library for compatibility.');\n  }\n\n  // cached factories and instances\n  var factories = [];\n  var instances = [];\n\n  // create a namespace for the mathjs instance, and attach emitter functions\n  var math = emitter.mixin({});\n  math.type = {};\n  math.expression = {\n    transform: {},\n    mathWithTransform: {}\n\n    // create a new typed instance\n  };math.typed = typedFactory.create(math.type);\n\n  // create configuration options. These are private\n  var _config = {\n    // minimum relative difference between two compared values,\n    // used by all comparison functions\n    epsilon: 1e-12,\n\n    // type of default matrix output. Choose 'matrix' (default) or 'array'\n    matrix: 'Matrix',\n\n    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction\n    number: 'number',\n\n    // number of significant digits in BigNumbers\n    precision: 64,\n\n    // predictable output type of functions. When true, output type depends only\n    // on the input types. When false (default), output type can vary depending\n    // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when\n    // predictable is false, and returns `NaN` when true.\n    predictable: false,\n\n    // random seed for seeded pseudo random number generation\n    // null = randomly seed\n    randomSeed: null\n\n    /**\n     * Load a function or data type from a factory.\n     * If the function or data type already exists, the existing instance is\n     * returned.\n     * @param {{type: string, name: string, factory: Function}} factory\n     * @returns {*}\n     */\n  };function load(factory) {\n    if (!isFactory(factory)) {\n      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');\n    }\n\n    var index = factories.indexOf(factory);\n    var instance = void 0;\n    if (index === -1) {\n      // doesn't yet exist\n      if (factory.math === true) {\n        // pass with math namespace\n        instance = factory.factory(math.type, _config, load, math.typed, math);\n      } else {\n        instance = factory.factory(math.type, _config, load, math.typed);\n      }\n\n      // append to the cache\n      factories.push(factory);\n      instances.push(instance);\n    } else {\n      // already existing function, return the cached instance\n      instance = instances[index];\n    }\n\n    return instance;\n  }\n\n  // load the import and config functions\n  math['import'] = load(importFactory);\n  math['config'] = load(configFactory);\n  math.expression.mathWithTransform['config'] = math['config'];\n\n  // apply options\n  if (options) {\n    math.config(options);\n  }\n\n  return math;\n};","'use strict';\n\n// TODO: remove these polyfills as soon as we have a build process that transpiles the code to ES5\n\n// Polyfill for IE 11 (Number.isFinite is used in `complex.js`)\n// source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite\nNumber.isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\n// Polyfill for IE 11\n// source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\nNumber.isNaN = Number.isNaN || function (value) {\n  return value !== value; // eslint-disable-line no-self-compare\n};","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar typedFunction = require('typed-function');\nvar digits = require('./../utils/number').digits;\nvar isBigNumber = require('./../utils/bignumber/isBigNumber');\nvar isMatrix = require('./../utils/collection/isMatrix');\n\n// returns a new instance of typed-function\nvar _createTyped = function createTyped() {\n  // initially, return the original instance of typed-function\n  // consecutively, return a new instance from typed.create.\n  _createTyped = typedFunction.create;\n  return typedFunction;\n};\n\n/**\n * Factory function for creating a new typed instance\n * @param {Object} type   Object with data types like Complex and BigNumber\n * @returns {Function}\n */\nexports.create = function create(type) {\n  // TODO: typed-function must be able to silently ignore signatures with unknown data types\n\n  // type checks for all known types\n  //\n  // note that:\n  //\n  // - check by duck-typing on a property like `isUnit`, instead of checking instanceof.\n  //   instanceof cannot be used because that would not allow to pass data from\n  //   one instance of math.js to another since each has it's own instance of Unit.\n  // - check the `isUnit` property via the constructor, so there will be no\n  //   matches for \"fake\" instances like plain objects with a property `isUnit`.\n  //   That is important for security reasons.\n  // - It must not be possible to override the type checks used internally,\n  //   for security reasons, so these functions are not exposed in the expression\n  //   parser.\n  type.isNumber = function (x) {\n    return typeof x === 'number';\n  };\n  type.isComplex = function (x) {\n    return type.Complex && x instanceof type.Complex || false;\n  };\n  type.isBigNumber = isBigNumber;\n  type.isFraction = function (x) {\n    return type.Fraction && x instanceof type.Fraction || false;\n  };\n  type.isUnit = function (x) {\n    return x && x.constructor.prototype.isUnit || false;\n  };\n  type.isString = function (x) {\n    return typeof x === 'string';\n  };\n  type.isArray = Array.isArray;\n  type.isMatrix = isMatrix;\n  type.isDenseMatrix = function (x) {\n    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix || false;\n  };\n  type.isSparseMatrix = function (x) {\n    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix || false;\n  };\n  type.isRange = function (x) {\n    return x && x.constructor.prototype.isRange || false;\n  };\n  type.isIndex = function (x) {\n    return x && x.constructor.prototype.isIndex || false;\n  };\n  type.isBoolean = function (x) {\n    return typeof x === 'boolean';\n  };\n  type.isResultSet = function (x) {\n    return x && x.constructor.prototype.isResultSet || false;\n  };\n  type.isHelp = function (x) {\n    return x && x.constructor.prototype.isHelp || false;\n  };\n  type.isFunction = function (x) {\n    return typeof x === 'function';\n  };\n  type.isDate = function (x) {\n    return x instanceof Date;\n  };\n  type.isRegExp = function (x) {\n    return x instanceof RegExp;\n  };\n  type.isObject = function (x) {\n    return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x.constructor === Object && !type.isComplex(x) && !type.isFraction(x);\n  };\n  type.isNull = function (x) {\n    return x === null;\n  };\n  type.isUndefined = function (x) {\n    return x === undefined;\n  };\n\n  type.isAccessorNode = function (x) {\n    return x && x.isAccessorNode && x.constructor.prototype.isNode || false;\n  };\n  type.isArrayNode = function (x) {\n    return x && x.isArrayNode && x.constructor.prototype.isNode || false;\n  };\n  type.isAssignmentNode = function (x) {\n    return x && x.isAssignmentNode && x.constructor.prototype.isNode || false;\n  };\n  type.isBlockNode = function (x) {\n    return x && x.isBlockNode && x.constructor.prototype.isNode || false;\n  };\n  type.isConditionalNode = function (x) {\n    return x && x.isConditionalNode && x.constructor.prototype.isNode || false;\n  };\n  type.isConstantNode = function (x) {\n    return x && x.isConstantNode && x.constructor.prototype.isNode || false;\n  };\n  type.isFunctionAssignmentNode = function (x) {\n    return x && x.isFunctionAssignmentNode && x.constructor.prototype.isNode || false;\n  };\n  type.isFunctionNode = function (x) {\n    return x && x.isFunctionNode && x.constructor.prototype.isNode || false;\n  };\n  type.isIndexNode = function (x) {\n    return x && x.isIndexNode && x.constructor.prototype.isNode || false;\n  };\n  type.isNode = function (x) {\n    return x && x.isNode && x.constructor.prototype.isNode || false;\n  };\n  type.isObjectNode = function (x) {\n    return x && x.isObjectNode && x.constructor.prototype.isNode || false;\n  };\n  type.isOperatorNode = function (x) {\n    return x && x.isOperatorNode && x.constructor.prototype.isNode || false;\n  };\n  type.isParenthesisNode = function (x) {\n    return x && x.isParenthesisNode && x.constructor.prototype.isNode || false;\n  };\n  type.isRangeNode = function (x) {\n    return x && x.isRangeNode && x.constructor.prototype.isNode || false;\n  };\n  type.isSymbolNode = function (x) {\n    return x && x.isSymbolNode && x.constructor.prototype.isNode || false;\n  };\n\n  type.isChain = function (x) {\n    return x && x.constructor.prototype.isChain || false;\n  };\n\n  // get a new instance of typed-function\n  var typed = _createTyped();\n\n  // define all types. The order of the types determines in which order function\n  // arguments are type-checked (so for performance it's important to put the\n  // most used types first).\n  typed.types = [{ name: 'number', test: type.isNumber }, { name: 'Complex', test: type.isComplex }, { name: 'BigNumber', test: type.isBigNumber }, { name: 'Fraction', test: type.isFraction }, { name: 'Unit', test: type.isUnit }, { name: 'string', test: type.isString }, { name: 'Array', test: type.isArray }, { name: 'Matrix', test: type.isMatrix }, { name: 'DenseMatrix', test: type.isDenseMatrix }, { name: 'SparseMatrix', test: type.isSparseMatrix }, { name: 'Range', test: type.isRange }, { name: 'Index', test: type.isIndex }, { name: 'boolean', test: type.isBoolean }, { name: 'ResultSet', test: type.isResultSet }, { name: 'Help', test: type.isHelp }, { name: 'function', test: type.isFunction }, { name: 'Date', test: type.isDate }, { name: 'RegExp', test: type.isRegExp }, { name: 'null', test: type.isNull }, { name: 'undefined', test: type.isUndefined }, { name: 'OperatorNode', test: type.isOperatorNode }, { name: 'ConstantNode', test: type.isConstantNode }, { name: 'SymbolNode', test: type.isSymbolNode }, { name: 'ParenthesisNode', test: type.isParenthesisNode }, { name: 'FunctionNode', test: type.isFunctionNode }, { name: 'FunctionAssignmentNode', test: type.isFunctionAssignmentNode }, { name: 'ArrayNode', test: type.isArrayNode }, { name: 'AssignmentNode', test: type.isAssignmentNode }, { name: 'BlockNode', test: type.isBlockNode }, { name: 'ConditionalNode', test: type.isConditionalNode }, { name: 'IndexNode', test: type.isIndexNode }, { name: 'RangeNode', test: type.isRangeNode }, { name: 'Node', test: type.isNode }, { name: 'Object', test: type.isObject // order 'Object' last, it matches on other classes too\n  }];\n\n  // TODO: add conversion from BigNumber to number?\n  typed.conversions = [{\n    from: 'number',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      // note: conversion from number to BigNumber can fail if x has >15 digits\n      if (digits(x) > 15) {\n        throw new TypeError('Cannot implicitly convert a number with >15 significant digits to BigNumber ' + '(value: ' + x + '). ' + 'Use function bignumber(x) to convert to BigNumber.');\n      }\n      return new type.BigNumber(x);\n    }\n  }, {\n    from: 'number',\n    to: 'Complex',\n    convert: function convert(x) {\n      return new type.Complex(x, 0);\n    }\n  }, {\n    from: 'number',\n    to: 'string',\n    convert: function convert(x) {\n      return x + '';\n    }\n  }, {\n    from: 'BigNumber',\n    to: 'Complex',\n    convert: function convert(x) {\n      return new type.Complex(x.toNumber(), 0);\n    }\n  }, {\n    from: 'Fraction',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      throw new TypeError('Cannot implicitly convert a Fraction to BigNumber or vice versa. ' + 'Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.');\n    }\n  }, {\n    from: 'Fraction',\n    to: 'Complex',\n    convert: function convert(x) {\n      return new type.Complex(x.valueOf(), 0);\n    }\n  }, {\n    from: 'number',\n    to: 'Fraction',\n    convert: function convert(x) {\n      var f = new type.Fraction(x);\n      if (f.valueOf() !== x) {\n        throw new TypeError('Cannot implicitly convert a number to a Fraction when there will be a loss of precision ' + '(value: ' + x + '). ' + 'Use function fraction(x) to convert to Fraction.');\n      }\n      return new type.Fraction(x);\n    }\n  }, {\n    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`\n    //  from: 'Fraction',\n    //  to: 'number',\n    //  convert: function (x) {\n    //    return x.valueOf()\n    //  }\n    // }, {\n    from: 'string',\n    to: 'number',\n    convert: function convert(x) {\n      var n = Number(x);\n      if (isNaN(n)) {\n        throw new Error('Cannot convert \"' + x + '\" to a number');\n      }\n      return n;\n    }\n  }, {\n    from: 'string',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      try {\n        return new type.BigNumber(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to BigNumber');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Fraction',\n    convert: function convert(x) {\n      try {\n        return new type.Fraction(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Fraction');\n      }\n    }\n  }, {\n    from: 'string',\n    to: 'Complex',\n    convert: function convert(x) {\n      try {\n        return new type.Complex(x);\n      } catch (err) {\n        throw new Error('Cannot convert \"' + x + '\" to Complex');\n      }\n    }\n  }, {\n    from: 'boolean',\n    to: 'number',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'boolean',\n    to: 'BigNumber',\n    convert: function convert(x) {\n      return new type.BigNumber(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'Fraction',\n    convert: function convert(x) {\n      return new type.Fraction(+x);\n    }\n  }, {\n    from: 'boolean',\n    to: 'string',\n    convert: function convert(x) {\n      return +x;\n    }\n  }, {\n    from: 'Array',\n    to: 'Matrix',\n    convert: function convert(array) {\n      return new type.DenseMatrix(array);\n    }\n  }, {\n    from: 'Matrix',\n    to: 'Array',\n    convert: function convert(matrix) {\n      return matrix.valueOf();\n    }\n  }];\n\n  return typed;\n};","/**\n * typed-function\n *\n * Type checking for JavaScript functions\n *\n * https://github.com/josdejong/typed-function\n */\n'use strict';\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // OldNode. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like OldNode.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.typed = factory();\n  }\n}(this, function () {\n\n  function ok () {\n    return true;\n  }\n\n  function notOk () {\n    return false;\n  }\n\n  function undef () {\n    return undefined;\n  }\n\n  /**\n   * @typedef {{\n   *   params: Param[],\n   *   fn: function\n   * }} Signature\n   *\n   * @typedef {{\n   *   types: Type[],\n   *   restParam: boolean\n   * }} Param\n   *\n   * @typedef {{\n   *   name: string,\n   *   typeIndex: number,\n   *   test: function,\n   *   conversion?: ConversionDef,\n   *   conversionIndex: number,\n   * }} Type\n   *\n   * @typedef {{\n   *   from: string,\n   *   to: string,\n   *   convert: function (*) : *\n   * }} ConversionDef\n   *\n   * @typedef {{\n   *   name: string,\n   *   test: function(*) : boolean\n   * }} TypeDef\n   */\n\n  // create a new instance of typed-function\n  function create () {\n    // data type tests\n    var _types = [\n      { name: 'number',    test: function (x) { return typeof x === 'number' } },\n      { name: 'string',    test: function (x) { return typeof x === 'string' } },\n      { name: 'boolean',   test: function (x) { return typeof x === 'boolean' } },\n      { name: 'Function',  test: function (x) { return typeof x === 'function'} },\n      { name: 'Array',     test: Array.isArray },\n      { name: 'Date',      test: function (x) { return x instanceof Date } },\n      { name: 'RegExp',    test: function (x) { return x instanceof RegExp } },\n      { name: 'Object',    test: function (x) {\n        return typeof x === 'object' && x.constructor === Object\n      }},\n      { name: 'null',      test: function (x) { return x === null } },\n      { name: 'undefined', test: function (x) { return x === undefined } }\n    ];\n\n    var anyType = {\n      name: 'any',\n      test: ok\n    }\n\n    // types which need to be ignored\n    var _ignore = [];\n\n    // type conversions\n    var _conversions = [];\n\n    // This is a temporary object, will be replaced with a typed function at the end\n    var typed = {\n      types: _types,\n      conversions: _conversions,\n      ignore: _ignore\n    };\n\n    /**\n     * Find the test function for a type\n     * @param {String} typeName\n     * @return {TypeDef} Returns the type definition when found,\n     *                    Throws a TypeError otherwise\n     */\n    function findTypeByName (typeName) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.name === typeName;\n      });\n\n      if (entry) {\n        return entry;\n      }\n\n      if (typeName === 'any') { // special baked-in case 'any'\n        return anyType;\n      }\n\n      var hint = findInArray(typed.types, function (entry) {\n        return entry.name.toLowerCase() === typeName.toLowerCase();\n      });\n\n      throw new TypeError('Unknown type \"' + typeName + '\"' +\n          (hint ? ('. Did you mean \"' + hint.name + '\"?') : ''));\n    }\n\n    /**\n     * Find the index of a type definition. Handles special case 'any'\n     * @param {TypeDef} type\n     * @return {number}\n     */\n    function findTypeIndex(type) {\n      if (type === anyType) {\n        return 999;\n      }\n\n      return typed.types.indexOf(type);\n    }\n\n    /**\n     * Find a type that matches a value.\n     * @param {*} value\n     * @return {string} Returns the name of the first type for which\n     *                  the type test matches the value.\n     */\n    function findTypeName(value) {\n      var entry = findInArray(typed.types, function (entry) {\n        return entry.test(value);\n      });\n\n      if (entry) {\n        return entry.name;\n      }\n\n      throw new TypeError('Value has unknown type. Value: ' + value);\n    }\n\n    /**\n     * Find a specific signature from a (composed) typed function, for example:\n     *\n     *   typed.find(fn, ['number', 'string'])\n     *   typed.find(fn, 'number, string')\n     *\n     * Function find only only works for exact matches.\n     *\n     * @param {Function} fn                   A typed-function\n     * @param {string | string[]} signature   Signature to be found, can be\n     *                                        an array or a comma separated string.\n     * @return {Function}                     Returns the matching signature, or\n     *                                        throws an error when no signature\n     *                                        is found.\n     */\n    function find (fn, signature) {\n      if (!fn.signatures) {\n        throw new TypeError('Function is no typed-function');\n      }\n\n      // normalize input\n      var arr;\n      if (typeof signature === 'string') {\n        arr = signature.split(',');\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = arr[i].trim();\n        }\n      }\n      else if (Array.isArray(signature)) {\n        arr = signature;\n      }\n      else {\n        throw new TypeError('String array or a comma separated string expected');\n      }\n\n      var str = arr.join(',');\n\n      // find an exact match\n      var match = fn.signatures[str];\n      if (match) {\n        return match;\n      }\n\n      // TODO: extend find to match non-exact signatures\n\n      throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + arr.join(', ') + '))');\n    }\n\n    /**\n     * Convert a given value to another data type.\n     * @param {*} value\n     * @param {string} type\n     */\n    function convert (value, type) {\n      var from = findTypeName(value);\n\n      // check conversion is needed\n      if (type === from) {\n        return value;\n      }\n\n      for (var i = 0; i < typed.conversions.length; i++) {\n        var conversion = typed.conversions[i];\n        if (conversion.from === from && conversion.to === type) {\n          return conversion.convert(value);\n        }\n      }\n\n      throw new Error('Cannot convert from ' + from + ' to ' + type);\n    }\n    \n    /**\n     * Stringify parameters in a normalized way\n     * @param {Param[]} params\n     * @return {string}\n     */\n    function stringifyParams (params) {\n      return params\n          .map(function (param) {\n            var typeNames = param.types.map(getTypeName);\n\n            return (param.restParam ? '...' : '') + typeNames.join('|');\n          })\n          .join(',');\n    }\n\n    /**\n     * Parse a parameter, like \"...number | boolean\"\n     * @param {string} param\n     * @param {ConversionDef[]} conversions\n     * @return {Param} param\n     */\n    function parseParam (param, conversions) {\n      var restParam = param.indexOf('...') === 0;\n      var types = (!restParam)\n          ? param\n          : (param.length > 3)\n              ? param.slice(3)\n              : 'any';\n\n      var typeNames = types.split('|').map(trim)\n          .filter(notEmpty)\n          .filter(notIgnore);\n\n      var matchingConversions = filterConversions(conversions, typeNames);\n\n      var exactTypes = typeNames.map(function (typeName) {\n        var type = findTypeByName(typeName);\n\n        return {\n          name: typeName,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: null,\n          conversionIndex: -1\n        };\n      });\n\n      var convertibleTypes = matchingConversions.map(function (conversion) {\n        var type = findTypeByName(conversion.from);\n\n        return {\n          name: conversion.from,\n          typeIndex: findTypeIndex(type),\n          test: type.test,\n          conversion: conversion,\n          conversionIndex: conversions.indexOf(conversion)\n        };\n      });\n\n      return {\n        types: exactTypes.concat(convertibleTypes),\n        restParam: restParam\n      };\n    }\n\n    /**\n     * Parse a signature with comma separated parameters,\n     * like \"number | boolean, ...string\"\n     * @param {string} signature\n     * @param {function} fn\n     * @param {ConversionDef[]} conversions\n     * @return {Signature | null} signature\n     */\n    function parseSignature (signature, fn, conversions) {\n      var params = [];\n\n      if (signature.trim() !== '') {\n        params = signature\n            .split(',')\n            .map(trim)\n            .map(function (param, index, array) {\n              var parsedParam = parseParam(param, conversions);\n\n              if (parsedParam.restParam && (index !== array.length - 1)) {\n                throw new SyntaxError('Unexpected rest parameter \"' + param + '\": ' +\n                    'only allowed for the last parameter');\n              }\n\n              return parsedParam;\n          });\n      }\n\n      if (params.some(isInvalidParam)) {\n        // invalid signature: at least one parameter has no types\n        // (they may have been filtered)\n        return null;\n      }\n\n      return {\n        params: params,\n        fn: fn\n      };\n    }\n\n    /**\n     * Test whether a set of params contains a restParam\n     * @param {Param[]} params\n     * @return {boolean} Returns true when the last parameter is a restParam\n     */\n    function hasRestParam(params) {\n      var param = last(params)\n      return param ? param.restParam : false;\n    }\n\n    /**\n     * Test whether a parameter contains conversions\n     * @param {Param} param\n     * @return {boolean} Returns true when at least one of the parameters\n     *                   contains a conversion.\n     */\n    function hasConversions(param) {\n      return param.types.some(function (type) {\n        return type.conversion != null;\n      });\n    }\n\n    /**\n     * Create a type test for a single parameter, which can have one or multiple\n     * types.\n     * @param {Param} param\n     * @return {function(x: *) : boolean} Returns a test function\n     */\n    function compileTest(param) {\n      if (!param || param.types.length === 0) {\n        // nothing to do\n        return ok;\n      }\n      else if (param.types.length === 1) {\n        return findTypeByName(param.types[0].name).test;\n      }\n      else if (param.types.length === 2) {\n        var test0 = findTypeByName(param.types[0].name).test;\n        var test1 = findTypeByName(param.types[1].name).test;\n        return function or(x) {\n          return test0(x) || test1(x);\n        }\n      }\n      else { // param.types.length > 2\n        var tests = param.types.map(function (type) {\n          return findTypeByName(type.name).test;\n        })\n        return function or(x) {\n          for (var i = 0; i < tests.length; i++) {\n            if (tests[i](x)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Create a test for all parameters of a signature\n     * @param {Param[]} params\n     * @return {function(args: Array<*>) : boolean}\n     */\n    function compileTests(params) {\n      var tests, test0, test1;\n\n      if (hasRestParam(params)) {\n        // variable arguments like '...number'\n        tests = initial(params).map(compileTest);\n        var varIndex = tests.length;\n        var lastTest = compileTest(last(params));\n        var testRestParam = function (args) {\n          for (var i = varIndex; i < args.length; i++) {\n            if (!lastTest(args[i])) {\n              return false;\n            }\n          }\n          return true;\n        }\n\n        return function testArgs(args) {\n          for (var i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false;\n            }\n          }\n          return testRestParam(args) && (args.length >= varIndex + 1);\n        };\n      }\n      else {\n        // no variable arguments\n        if (params.length === 0) {\n          return function testArgs(args) {\n            return args.length === 0;\n          };\n        }\n        else if (params.length === 1) {\n          test0 = compileTest(params[0]);\n          return function testArgs(args) {\n            return test0(args[0]) && args.length === 1;\n          };\n        }\n        else if (params.length === 2) {\n          test0 = compileTest(params[0]);\n          test1 = compileTest(params[1]);\n          return function testArgs(args) {\n            return test0(args[0]) && test1(args[1]) && args.length === 2;\n          };\n        }\n        else { // arguments.length > 2\n          tests = params.map(compileTest);\n          return function testArgs(args) {\n            for (var i = 0; i < tests.length; i++) {\n              if (!tests[i](args[i])) {\n                return false;\n              }\n            }\n            return args.length === tests.length;\n          };\n        }\n      }\n    }\n\n    /**\n     * Find the parameter at a specific index of a signature.\n     * Handles rest parameters.\n     * @param {Signature} signature\n     * @param {number} index\n     * @return {Param | null} Returns the matching parameter when found,\n     *                        null otherwise.\n     */\n    function getParamAtIndex(signature, index) {\n      return index < signature.params.length\n          ? signature.params[index]\n          : hasRestParam(signature.params)\n              ? last(signature.params)\n              : null\n    }\n\n    /**\n     * Get all type names of a parameter\n     * @param {Signature} signature\n     * @param {number} index\n     * @param {boolean} excludeConversions\n     * @return {string[]} Returns an array with type names\n     */\n    function getExpectedTypeNames (signature, index, excludeConversions) {\n      var param = getParamAtIndex(signature, index);\n      var types = param\n          ? excludeConversions\n                  ? param.types.filter(isExactType)\n                  : param.types\n          : [];\n\n      return types.map(getTypeName);\n    }\n\n    /**\n     * Returns the name of a type\n     * @param {Type} type\n     * @return {string} Returns the type name\n     */\n    function getTypeName(type) {\n      return type.name;\n    }\n\n    /**\n     * Test whether a type is an exact type or conversion\n     * @param {Type} type\n     * @return {boolean} Returns true when\n     */\n    function isExactType(type) {\n      return type.conversion === null || type.conversion === undefined;\n    }\n\n    /**\n     * Helper function for creating error messages: create an array with\n     * all available types on a specific argument index.\n     * @param {Signature[]} signatures\n     * @param {number} index\n     * @return {string[]} Returns an array with available types\n     */\n    function mergeExpectedParams(signatures, index) {\n      var typeNames = uniq(flatMap(signatures, function (signature) {\n        return getExpectedTypeNames(signature, index, false);\n      }));\n\n      return (typeNames.indexOf('any') !== -1) ? ['any'] : typeNames;\n    }\n\n    /**\n     * Create\n     * @param {string} name             The name of the function\n     * @param {array.<*>} args          The actual arguments passed to the function\n     * @param {Signature[]} signatures  A list with available signatures\n     * @return {TypeError} Returns a type error with additional data\n     *                     attached to it in the property `data`\n     */\n    function createError(name, args, signatures) {\n      var err, expected;\n      var _name = name || 'unnamed';\n\n      // test for wrong type at some index\n      var matchingSignatures = signatures;\n      var index;\n      for (index = 0; index < args.length; index++) {\n        var nextMatchingDefs = matchingSignatures.filter(function (signature) {\n          var test = compileTest(getParamAtIndex(signature, index));\n          return (index < signature.params.length || hasRestParam(signature.params)) &&\n              test(args[index]);\n        });\n\n        if (nextMatchingDefs.length === 0) {\n          // no matching signatures anymore, throw error \"wrong type\"\n          expected = mergeExpectedParams(matchingSignatures, index);\n          if (expected.length > 0) {\n            var actualType = findTypeName(args[index]);\n\n            err = new TypeError('Unexpected type of argument in function ' + _name +\n                ' (expected: ' + expected.join(' or ') +\n                ', actual: ' + actualType + ', index: ' + index + ')');\n            err.data = {\n              category: 'wrongType',\n              fn: _name,\n              index: index,\n              actual: actualType,\n              expected: expected\n            }\n            return err;\n          }\n        }\n        else {\n          matchingSignatures = nextMatchingDefs;\n        }\n      }\n\n      // test for too few arguments\n      var lengths = matchingSignatures.map(function (signature) {\n        return hasRestParam(signature.params) ? Infinity : signature.params.length;\n      });\n      if (args.length < Math.min.apply(null, lengths)) {\n        expected = mergeExpectedParams(matchingSignatures, index);\n        err = new TypeError('Too few arguments in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', index: ' + args.length + ')');\n        err.data = {\n          category: 'tooFewArgs',\n          fn: _name,\n          index: args.length,\n          expected: expected\n        }\n        return err;\n      }\n\n      // test for too many arguments\n      var maxLength = Math.max.apply(null, lengths);\n      if (args.length > maxLength) {\n        err = new TypeError('Too many arguments in function ' + _name +\n            ' (expected: ' + maxLength + ', actual: ' + args.length + ')');\n        err.data = {\n          category: 'tooManyArgs',\n          fn: _name,\n          index: args.length,\n          expectedLength: maxLength\n        }\n        return err;\n      }\n\n      err = new TypeError('Arguments of type \"' + args.join(', ') +\n          '\" do not match any of the defined signatures of function ' + _name + '.');\n      err.data = {\n        category: 'mismatch',\n        actual: args.map(findTypeName)\n      }\n      return err;\n    }\n\n    /**\n     * Find the lowest index of all exact types of a parameter (no conversions)\n     * @param {Param} param\n     * @return {number} Returns the index of the lowest type in typed.types\n     */\n    function getLowestTypeIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].typeIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Find the lowest index of the conversion of all types of the parameter\n     * having a conversion\n     * @param {Param} param\n     * @return {number} Returns the lowest index of the conversions of this type\n     */\n    function getLowestConversionIndex (param) {\n      var min = 999;\n\n      for (var i = 0; i < param.types.length; i++) {\n        if (!isExactType(param.types[i])) {\n          min = Math.min(min, param.types[i].conversionIndex);\n        }\n      }\n\n      return min;\n    }\n\n    /**\n     * Compare two params\n     * @param {Param} param1\n     * @param {Param} param2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareParams (param1, param2) {\n      var c;\n\n      // compare having a rest parameter or not\n      c = param1.restParam - param2.restParam;\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare having conversions or not\n      c = hasConversions(param1) - hasConversions(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of the types\n      c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);\n      if (c !== 0) {\n        return c;\n      }\n\n      // compare the index of any conversion\n      return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);\n    }\n\n    /**\n     * Compare two signatures\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {number} returns a negative number when param1 must get a lower\n     *                  index than param2, a positive number when the opposite,\n     *                  or zero when both are equal\n     */\n    function compareSignatures (signature1, signature2) {\n      var len = Math.min(signature1.params.length, signature2.params.length);\n      var i;\n      var c;\n\n      // compare whether the params have conversions at all or not\n      c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions)\n      if (c !== 0) {\n        return c;\n      }\n\n      // next compare whether the params have conversions one by one\n      for (i = 0; i < len; i++) {\n        c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the types of the params one by one\n      for (i = 0; i < len; i++) {\n        c = compareParams(signature1.params[i], signature2.params[i]);\n        if (c !== 0) {\n          return c;\n        }\n      }\n\n      // compare the number of params\n      return signature1.params.length - signature2.params.length;\n    }\n\n    /**\n     * Get params containing all types that can be converted to the defined types.\n     *\n     * @param {ConversionDef[]} conversions\n     * @param {string[]} typeNames\n     * @return {ConversionDef[]} Returns the conversions that are available\n     *                        for every type (if any)\n     */\n    function filterConversions(conversions, typeNames) {\n      var matches = {};\n\n      conversions.forEach(function (conversion) {\n        if (typeNames.indexOf(conversion.from) === -1 &&\n            typeNames.indexOf(conversion.to) !== -1 &&\n            !matches[conversion.from]) {\n          matches[conversion.from] = conversion;\n        }\n      });\n\n      return Object.keys(matches).map(function (from) {\n        return matches[from];\n      });\n    }\n\n    /**\n     * Preprocess arguments before calling the original function:\n     * - if needed convert the parameters\n     * - in case of rest parameters, move the rest parameters into an Array\n     * @param {Param[]} params\n     * @param {function} fn\n     * @return {function} Returns a wrapped function\n     */\n    function compileArgsPreprocessing(params, fn) {\n      var fnConvert = fn;\n\n      // TODO: can we make this wrapper function smarter/simpler?\n\n      if (params.some(hasConversions)) {\n        var restParam = hasRestParam(params);\n        var compiledConversions = params.map(compileArgConversion)\n\n        fnConvert = function convertArgs() {\n          var args = [];\n          var last = restParam ? arguments.length - 1 : arguments.length;\n          for (var i = 0; i < last; i++) {\n            args[i] = compiledConversions[i](arguments[i]);\n          }\n          if (restParam) {\n            args[last] = arguments[last].map(compiledConversions[last]);\n          }\n\n          return fn.apply(null, args);\n        }\n      }\n\n      var fnPreprocess = fnConvert;\n      if (hasRestParam(params)) {\n        var offset = params.length - 1;\n\n        fnPreprocess = function preprocessRestParams () {\n          return fnConvert.apply(null,\n              slice(arguments, 0, offset).concat([slice(arguments, offset)]));\n        }\n      }\n\n      return fnPreprocess;\n    }\n\n    /**\n     * Compile conversion for a parameter to the right type\n     * @param {Param} param\n     * @return {function} Returns the wrapped function that will convert arguments\n     *\n     */\n    function compileArgConversion(param) {\n      var test0, test1, conversion0, conversion1;\n      var tests = [];\n      var conversions = [];\n\n      param.types.forEach(function (type) {\n        if (type.conversion) {\n          tests.push(findTypeByName(type.conversion.from).test);\n          conversions.push(type.conversion.convert);\n        }\n      });\n\n      // create optimized conversion functions depending on the number of conversions\n      switch (conversions.length) {\n        case 0:\n          return function convertArg(arg) {\n            return arg;\n          }\n\n        case 1:\n          test0 = tests[0]\n          conversion0 = conversions[0];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            return arg;\n          }\n\n        case 2:\n          test0 = tests[0]\n          test1 = tests[1]\n          conversion0 = conversions[0];\n          conversion1 = conversions[1];\n          return function convertArg(arg) {\n            if (test0(arg)) {\n              return conversion0(arg)\n            }\n            if (test1(arg)) {\n              return conversion1(arg)\n            }\n            return arg;\n          }\n\n        default:\n          return function convertArg(arg) {\n            for (var i = 0; i < conversions.length; i++) {\n              if (tests[i](arg)) {\n                return conversions[i](arg);\n              }\n            }\n            return arg;\n          }\n      }\n    }\n\n    /**\n     * Convert an array with signatures into a map with signatures,\n     * where signatures with union types are split into separate signatures\n     *\n     * Throws an error when there are conflicting types\n     *\n     * @param {Signature[]} signatures\n     * @return {Object.<string, function>}  Returns a map with signatures\n     *                                      as key and the original function\n     *                                      of this signature as value.\n     */\n    function createSignaturesMap(signatures) {\n      var signaturesMap = {};\n      signatures.forEach(function (signature) {\n        if (!signature.params.some(hasConversions)) {\n          splitParams(signature.params, true).forEach(function (params) {\n            signaturesMap[stringifyParams(params)] = signature.fn;\n          });\n        }\n      });\n\n      return signaturesMap;\n    }\n\n    /**\n     * Split params with union types in to separate params.\n     *\n     * For example:\n     *\n     *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n     *     // returns:\n     *     // [\n     *     //   ['Array', 'string'],\n     *     //   ['Array', 'RegExp'],\n     *     //   ['Object', 'string'],\n     *     //   ['Object', 'RegExp']\n     *     // ]\n     *\n     * @param {Param[]} params\n     * @param {boolean} ignoreConversionTypes\n     * @return {Param[]}\n     */\n    function splitParams(params, ignoreConversionTypes) {\n      function _splitParams(params, index, types) {\n        if (index < params.length) {\n          var param = params[index]\n          var filteredTypes = ignoreConversionTypes\n              ? param.types.filter(isExactType)\n              : param.types;\n          var typeGroups\n\n          if (param.restParam) {\n            // split the types of a rest parameter in two:\n            // one with only exact types, and one with exact types and conversions\n            var exactTypes = filteredTypes.filter(isExactType)\n            typeGroups = exactTypes.length < filteredTypes.length\n                ? [exactTypes, filteredTypes]\n                : [filteredTypes]\n\n          }\n          else {\n            // split all the types of a regular parameter into one type per group\n            typeGroups = filteredTypes.map(function (type) {\n              return [type]\n            })\n          }\n\n          // recurse over the groups with types\n          return flatMap(typeGroups, function (typeGroup) {\n            return _splitParams(params, index + 1, types.concat([typeGroup]));\n          });\n\n        }\n        else {\n          // we've reached the end of the parameters. Now build a new Param\n          var splittedParams = types.map(function (type, typeIndex) {\n            return {\n              types: type,\n              restParam: (typeIndex === params.length - 1) && hasRestParam(params)\n            }\n          });\n\n          return [splittedParams];\n        }\n      }\n\n      return _splitParams(params, 0, []);\n    }\n\n    /**\n     * Test whether two signatures have a conflicting signature\n     * @param {Signature} signature1\n     * @param {Signature} signature2\n     * @return {boolean} Returns true when the signatures conflict, false otherwise.\n     */\n    function hasConflictingParams(signature1, signature2) {\n      var ii = Math.max(signature1.params.length, signature2.params.length);\n\n      for (var i = 0; i < ii; i++) {\n        var typesNames1 = getExpectedTypeNames(signature1, i, true);\n        var typesNames2 = getExpectedTypeNames(signature2, i, true);\n\n        if (!hasOverlap(typesNames1, typesNames2)) {\n          return false;\n        }\n      }\n\n      var len1 = signature1.params.length;\n      var len2 = signature2.params.length;\n      var restParam1 = hasRestParam(signature1.params);\n      var restParam2 = hasRestParam(signature2.params);\n\n      return restParam1\n          ? restParam2 ? (len1 === len2) : (len2 >= len1)\n          : restParam2 ? (len1 >= len2)  : (len1 === len2)\n    }\n\n    /**\n     * Create a typed function\n     * @param {String} name               The name for the typed function\n     * @param {Object.<string, function>} signaturesMap\n     *                                    An object with one or\n     *                                    multiple signatures as key, and the\n     *                                    function corresponding to the\n     *                                    signature as value.\n     * @return {function}  Returns the created typed function.\n     */\n    function createTypedFunction(name, signaturesMap) {\n      if (Object.keys(signaturesMap).length === 0) {\n        throw new SyntaxError('No signatures provided');\n      }\n\n      // parse the signatures, and check for conflicts\n      var parsedSignatures = [];\n      Object.keys(signaturesMap)\n          .map(function (signature) {\n            return parseSignature(signature, signaturesMap[signature], typed.conversions);\n          })\n          .filter(notNull)\n          .forEach(function (parsedSignature) {\n            // check whether this parameter conflicts with already parsed signatures\n            var conflictingSignature = findInArray(parsedSignatures, function (s) {\n              return hasConflictingParams(s, parsedSignature)\n            });\n            if (conflictingSignature) {\n              throw new TypeError('Conflicting signatures \"' +\n                  stringifyParams(conflictingSignature.params) + '\" and \"' +\n                  stringifyParams(parsedSignature.params) + '\".');\n            }\n\n            parsedSignatures.push(parsedSignature);\n          });\n\n      // split and filter the types of the signatures, and then order them\n      var signatures = flatMap(parsedSignatures, function (parsedSignature) {\n        var params = parsedSignature ? splitParams(parsedSignature.params, false) : []\n\n        return params.map(function (params) {\n          return {\n            params: params,\n            fn: parsedSignature.fn\n          };\n        });\n      }).filter(notNull);\n\n      signatures.sort(compareSignatures);\n\n      // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n      var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);\n      var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);\n      var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);\n      var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);\n      var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);\n      var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);\n      var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;\n\n      // compile the tests\n      var tests = signatures.map(function (signature) {\n        return compileTests(signature.params);\n      });\n\n      var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;\n      var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;\n      var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;\n      var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;\n      var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;\n      var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;\n\n      var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;\n      var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;\n      var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;\n      var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;\n      var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;\n      var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;\n\n      // compile the functions\n      var fns = signatures.map(function(signature) {\n        return compileArgsPreprocessing(signature.params, signature.fn)\n      });\n\n      var fn0 = ok0 ? fns[0] : undef;\n      var fn1 = ok1 ? fns[1] : undef;\n      var fn2 = ok2 ? fns[2] : undef;\n      var fn3 = ok3 ? fns[3] : undef;\n      var fn4 = ok4 ? fns[4] : undef;\n      var fn5 = ok5 ? fns[5] : undef;\n\n      var len0 = ok0 ? signatures[0].params.length : -1;\n      var len1 = ok1 ? signatures[1].params.length : -1;\n      var len2 = ok2 ? signatures[2].params.length : -1;\n      var len3 = ok3 ? signatures[3].params.length : -1;\n      var len4 = ok4 ? signatures[4].params.length : -1;\n      var len5 = ok5 ? signatures[5].params.length : -1;\n\n      // simple and generic, but also slow\n      var iStart = allOk ? 6 : 0;\n      var iEnd = signatures.length;\n      var generic = function generic() {\n        'use strict';\n\n        for (var i = iStart; i < iEnd; i++) {\n          if (tests[i](arguments)) {\n            return fns[i].apply(null, arguments);\n          }\n        }\n\n        throw createError(name, arguments, signatures);\n      }\n\n      // create the typed function\n      // fast, specialized version. Falls back to the slower, generic one if needed\n      var fn = function fn(arg0, arg1) {\n        'use strict';\n\n        if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(null, arguments); }\n        if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(null, arguments); }\n        if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(null, arguments); }\n        if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(null, arguments); }\n        if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(null, arguments); }\n        if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(null, arguments); }\n\n        return generic.apply(null, arguments);\n      }\n\n      // attach name the typed function\n      try {\n        Object.defineProperty(fn, 'name', {value: name});\n      }\n      catch (err) {\n        // old browsers do not support Object.defineProperty and some don't support setting the name property\n        // the function name is not essential for the functioning, it's mostly useful for debugging,\n        // so it's fine to have unnamed functions.\n      }\n\n      // attach signatures to the function\n      fn.signatures = createSignaturesMap(signatures);\n\n      return fn;\n    }\n\n    /**\n     * Test whether a type should be NOT be ignored\n     * @param {string} typeName\n     * @return {boolean}\n     */\n    function notIgnore(typeName) {\n      return typed.ignore.indexOf(typeName) === -1;\n    }\n\n    /**\n     * trim a string\n     * @param {string} str\n     * @return {string}\n     */\n    function trim(str) {\n      return str.trim();\n    }\n\n    /**\n     * Test whether a string is not empty\n     * @param {string} str\n     * @return {boolean}\n     */\n    function notEmpty(str) {\n      return !!str;\n    }\n\n    /**\n     * test whether a value is not strict equal to null\n     * @param {*} value\n     * @return {boolean}\n     */\n    function notNull(value) {\n      return value !== null;\n    }\n\n    /**\n     * Test whether a parameter has no types defined\n     * @param {Param} param\n     * @return {boolean}\n     */\n    function isInvalidParam (param) {\n      return param.types.length === 0;\n    }\n\n    /**\n     * Return all but the last items of an array\n     * @param {Array} arr\n     * @return {Array}\n     */\n    function initial(arr) {\n      return arr.slice(0, arr.length - 1);\n    }\n\n    /**\n     * return the last item of an array\n     * @param {Array} arr\n     * @return {*}\n     */\n    function last(arr) {\n      return arr[arr.length - 1];\n    }\n\n    /**\n     * Slice an array or function Arguments\n     * @param {Array | Arguments | IArguments} arr\n     * @param {number} start\n     * @param {number} [end]\n     * @return {Array}\n     */\n    function slice(arr, start, end) {\n      return Array.prototype.slice.call(arr, start, end);\n    }\n\n    /**\n     * Test whether an array contains some item\n     * @param {Array} array\n     * @param {*} item\n     * @return {boolean} Returns true if array contains item, false if not.\n     */\n    function contains(array, item) {\n      return array.indexOf(item) !== -1;\n    }\n\n    /**\n     * Test whether two arrays have overlapping items\n     * @param {Array} array1\n     * @param {Array} array2\n     * @return {boolean} Returns true when at least one item exists in both arrays\n     */\n    function hasOverlap(array1, array2) {\n      for (var i = 0; i < array1.length; i++) {\n        if (contains(array2, array1[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Return the first item from an array for which test(arr[i]) returns true\n     * @param {Array} arr\n     * @param {function} test\n     * @return {* | undefined} Returns the first matching item\n     *                         or undefined when there is no match\n     */\n    function findInArray(arr, test) {\n      for (var i = 0; i < arr.length; i++) {\n        if (test(arr[i])) {\n          return arr[i];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Filter unique items of an array with strings\n     * @param {string[]} arr\n     * @return {string[]}\n     */\n    function uniq(arr) {\n      var entries = {}\n      for (var i = 0; i < arr.length; i++) {\n        entries[arr[i]] = true;\n      }\n      return Object.keys(entries);\n    }\n\n    /**\n     * Flat map the result invoking a callback for every item in an array.\n     * https://gist.github.com/samgiles/762ee337dff48623e729\n     * @param {Array} arr\n     * @param {function} callback\n     * @return {Array}\n     */\n    function flatMap(arr, callback) {\n      return Array.prototype.concat.apply([], arr.map(callback));\n    }\n\n    /**\n     * Retrieve the function name from a set of typed functions,\n     * and check whether the name of all functions match (if given)\n     * @param {function[]} fns\n     */\n    function getName (fns) {\n      var name = '';\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // check whether the names are the same when defined\n        if ((typeof fn.signatures === 'object' || typeof fn.signature === 'string') && fn.name !== '') {\n          if (name === '') {\n            name = fn.name;\n          }\n          else if (name !== fn.name) {\n            var err = new Error('Function names do not match (expected: ' + name + ', actual: ' + fn.name + ')');\n            err.data = {\n              actual: fn.name,\n              expected: name\n            };\n            throw err;\n          }\n        }\n      }\n\n      return name;\n    }\n\n    // extract and merge all signatures of a list with typed functions\n    function extractSignatures(fns) {\n      var err;\n      var signaturesMap = {};\n\n      function validateUnique(_signature, _fn) {\n        if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {\n          err = new Error('Signature \"' + _signature + '\" is defined twice');\n          err.data = {signature: _signature};\n          throw err;\n          // else: both signatures point to the same function, that's fine\n        }\n      }\n\n      for (var i = 0; i < fns.length; i++) {\n        var fn = fns[i];\n\n        // test whether this is a typed-function\n        if (typeof fn.signatures === 'object') {\n          // merge the signatures\n          for (var signature in fn.signatures) {\n            if (fn.signatures.hasOwnProperty(signature)) {\n              validateUnique(signature, fn.signatures[signature]);\n              signaturesMap[signature] = fn.signatures[signature];\n            }\n          }\n        }\n        else if (typeof fn.signature === 'string') {\n          validateUnique(fn.signature, fn);\n          signaturesMap[fn.signature] = fn;\n        }\n        else {\n          err = new TypeError('Function is no typed-function (index: ' + i + ')');\n          err.data = {index: i};\n          throw err;\n        }\n      }\n\n      return signaturesMap;\n    }\n\n    typed = createTypedFunction('typed', {\n      'string, Object': createTypedFunction,\n      'Object': function (signaturesMap) {\n        // find existing name\n        var fns = [];\n        for (var signature in signaturesMap) {\n          if (signaturesMap.hasOwnProperty(signature)) {\n            fns.push(signaturesMap[signature]);\n          }\n        }\n        var name = getName(fns);\n        return createTypedFunction(name, signaturesMap);\n      },\n      '...Function': function (fns) {\n        return createTypedFunction(getName(fns), extractSignatures(fns));\n      },\n      'string, ...Function': function (name, fns) {\n        return createTypedFunction(name, extractSignatures(fns));\n      }\n    });\n\n    typed.create = create;\n    typed.types = _types;\n    typed.conversions = _conversions;\n    typed.ignore = _ignore;\n    typed.convert = convert;\n    typed.find = find;\n\n    /**\n     * add a type\n     * @param {{name: string, test: function}} type\n     * @param {boolean} [beforeObjectTest=true]\n     *                          If true, the new test will be inserted before\n     *                          the test with name 'Object' (if any), since\n     *                          tests for Object match Array and classes too.\n     */\n    typed.addType = function (type, beforeObjectTest) {\n      if (!type || typeof type.name !== 'string' || typeof type.test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected');\n      }\n\n      if (beforeObjectTest !== false) {\n        for (var i = 0; i < typed.types.length; i++) {\n          if (typed.types[i].name === 'Object') {\n            typed.types.splice(i, 0, type);\n            return\n          }\n        }\n      }\n\n      typed.types.push(type);\n    };\n\n    // add a conversion\n    typed.addConversion = function (conversion) {\n      if (!conversion\n          || typeof conversion.from !== 'string'\n          || typeof conversion.to !== 'string'\n          || typeof conversion.convert !== 'function') {\n        throw new TypeError('Object with properties {from: string, to: string, convert: function} expected');\n      }\n\n      typed.conversions.push(conversion);\n    };\n\n    return typed;\n  }\n\n  return create();\n}));","'use strict';\n\n/**\n * Test whether a value is a Matrix\n * @param {*} x\n * @returns {boolean} returns true with input is a Matrix\n *                    (like a DenseMatrix or SparseMatrix)\n */\n\nmodule.exports = function isMatrix(x) {\n  return x && x.constructor.prototype.isMatrix || false;\n};","'use strict';\n\nvar Emitter = require('tiny-emitter');\n\n/**\n * Extend given object with emitter functions `on`, `off`, `once`, `emit`\n * @param {Object} obj\n * @return {Object} obj\n */\nexports.mixin = function (obj) {\n  // create event emitter\n  var emitter = new Emitter();\n\n  // bind methods to obj (we don't want to expose the emitter.e Array...)\n  obj.on = emitter.on.bind(emitter);\n  obj.off = emitter.off.bind(emitter);\n  obj.once = emitter.once.bind(emitter);\n  obj.emit = emitter.emit.bind(emitter);\n\n  return obj;\n};","function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\n","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar lazy = require('../../utils/object').lazy;\nvar isFactory = require('../../utils/object').isFactory;\nvar traverse = require('../../utils/object').traverse;\nvar ArgumentsError = require('../../error/ArgumentsError');\n\nfunction factory(type, config, load, typed, math) {\n  /**\n   * Import functions from an object or a module\n   *\n   * Syntax:\n   *\n   *    math.import(object)\n   *    math.import(object, options)\n   *\n   * Where:\n   *\n   * - `object: Object`\n   *   An object with functions to be imported.\n   * - `options: Object` An object with import options. Available options:\n   *   - `override: boolean`\n   *     If true, existing functions will be overwritten. False by default.\n   *   - `silent: boolean`\n   *     If true, the function will not throw errors on duplicates or invalid\n   *     types. False by default.\n   *   - `wrap: boolean`\n   *     If true, the functions will be wrapped in a wrapper function\n   *     which converts data types like Matrix to primitive data types like Array.\n   *     The wrapper is needed when extending math.js with libraries which do not\n   *     support these data type. False by default.\n   *\n   * Examples:\n   *\n   *    // define new functions and variables\n   *    math.import({\n   *      myvalue: 42,\n   *      hello: function (name) {\n   *        return 'hello, ' + name + '!'\n   *      }\n   *    })\n   *\n   *    // use the imported function and variable\n   *    math.myvalue * 2               // 84\n   *    math.hello('user')             // 'hello, user!'\n   *\n   *    // import the npm module 'numbers'\n   *    // (must be installed first with `npm install numbers`)\n   *    math.import(require('numbers'), {wrap: true})\n   *\n   *    math.fibonacci(7) // returns 13\n   *\n   * @param {Object | Array} object   Object with functions to be imported.\n   * @param {Object} [options]        Import options.\n   */\n  function mathImport(object, options) {\n    var num = arguments.length;\n    if (num !== 1 && num !== 2) {\n      throw new ArgumentsError('import', num, 1, 2);\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    // TODO: allow a typed-function with name too\n    if (isFactory(object)) {\n      _importFactory(object, options);\n    } else if (Array.isArray(object)) {\n      object.forEach(function (entry) {\n        mathImport(entry, options);\n      });\n    } else if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object') {\n      // a map with functions\n      for (var name in object) {\n        if (object.hasOwnProperty(name)) {\n          var value = object[name];\n          if (isSupportedType(value)) {\n            _import(name, value, options);\n          } else if (isFactory(object)) {\n            _importFactory(object, options);\n          } else {\n            mathImport(value, options);\n          }\n        }\n      }\n    } else {\n      if (!options.silent) {\n        throw new TypeError('Factory, Object, or Array expected');\n      }\n    }\n  }\n\n  /**\n   * Add a property to the math namespace and create a chain proxy for it.\n   * @param {string} name\n   * @param {*} value\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n  function _import(name, value, options) {\n    // TODO: refactor this function, it's to complicated and contains duplicate code\n    if (options.wrap && typeof value === 'function') {\n      // create a wrapper around the function\n      value = _wrap(value);\n    }\n\n    if (isTypedFunction(math[name]) && isTypedFunction(value)) {\n      if (options.override) {\n        // give the typed function the right name\n        value = typed(name, value.signatures);\n      } else {\n        // merge the existing and typed function\n        value = typed(math[name], value);\n      }\n\n      math[name] = value;\n      _importTransform(name, value);\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (math[name] === undefined || options.override) {\n      math[name] = value;\n      _importTransform(name, value);\n      math.emit('import', name, function resolver() {\n        return value;\n      });\n      return;\n    }\n\n    if (!options.silent) {\n      throw new Error('Cannot import \"' + name + '\": already exists');\n    }\n  }\n\n  function _importTransform(name, value) {\n    if (value && typeof value.transform === 'function') {\n      math.expression.transform[name] = value.transform;\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value.transform;\n      }\n    } else {\n      // remove existing transform\n      delete math.expression.transform[name];\n      if (allowedInExpressions(name)) {\n        math.expression.mathWithTransform[name] = value;\n      }\n    }\n  }\n\n  function _deleteTransform(name) {\n    delete math.expression.transform[name];\n    if (allowedInExpressions(name)) {\n      math.expression.mathWithTransform[name] = math[name];\n    } else {\n      delete math.expression.mathWithTransform[name];\n    }\n  }\n\n  /**\n   * Create a wrapper a round an function which converts the arguments\n   * to their primitive values (like convert a Matrix to Array)\n   * @param {Function} fn\n   * @return {Function} Returns the wrapped function\n   * @private\n   */\n  function _wrap(fn) {\n    var wrapper = function wrapper() {\n      var args = [];\n      for (var i = 0, len = arguments.length; i < len; i++) {\n        var arg = arguments[i];\n        args[i] = arg && arg.valueOf();\n      }\n      return fn.apply(math, args);\n    };\n\n    if (fn.transform) {\n      wrapper.transform = fn.transform;\n    }\n\n    return wrapper;\n  }\n\n  /**\n   * Import an instance of a factory into math.js\n   * @param {{factory: Function, name: string, path: string, math: boolean}} factory\n   * @param {Object} options  See import for a description of the options\n   * @private\n   */\n  function _importFactory(factory, options) {\n    if (typeof factory.name === 'string') {\n      var name = factory.name;\n      var existingTransform = name in math.expression.transform;\n      var namespace = factory.path ? traverse(math, factory.path) : math;\n      var existing = namespace.hasOwnProperty(name) ? namespace[name] : undefined;\n\n      var resolver = function resolver() {\n        var instance = load(factory);\n        if (instance && typeof instance.transform === 'function') {\n          throw new Error('Transforms cannot be attached to factory functions. ' + 'Please create a separate function for it with exports.path=\"expression.transform\"');\n        }\n\n        if (isTypedFunction(existing) && isTypedFunction(instance)) {\n          if (options.override) {\n            // replace the existing typed function (nothing to do)\n          } else {\n            // merge the existing and new typed function\n            instance = typed(existing, instance);\n          }\n\n          return instance;\n        }\n\n        if (existing === undefined || options.override) {\n          return instance;\n        }\n\n        if (!options.silent) {\n          throw new Error('Cannot import \"' + name + '\": already exists');\n        }\n      };\n\n      if (factory.lazy !== false) {\n        lazy(namespace, name, resolver);\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || factoryAllowedInExpressions(factory)) {\n            lazy(math.expression.mathWithTransform, name, resolver);\n          }\n        }\n      } else {\n        namespace[name] = resolver();\n\n        if (existingTransform) {\n          _deleteTransform(name);\n        } else {\n          if (factory.path === 'expression.transform' || factoryAllowedInExpressions(factory)) {\n            math.expression.mathWithTransform[name] = resolver();\n          }\n        }\n      }\n\n      math.emit('import', name, resolver, factory.path);\n    } else {\n      // unnamed factory.\n      // no lazy loading\n      load(factory);\n    }\n  }\n\n  /**\n   * Check whether given object is a type which can be imported\n   * @param {Function | number | string | boolean | null | Unit | Complex} object\n   * @return {boolean}\n   * @private\n   */\n  function isSupportedType(object) {\n    return typeof object === 'function' || typeof object === 'number' || typeof object === 'string' || typeof object === 'boolean' || object === null || object && type.isUnit(object) || object && type.isComplex(object) || object && type.isBigNumber(object) || object && type.isFraction(object) || object && type.isMatrix(object) || object && Array.isArray(object);\n  }\n\n  /**\n   * Test whether a given thing is a typed-function\n   * @param {*} fn\n   * @return {boolean} Returns true when `fn` is a typed-function\n   */\n  function isTypedFunction(fn) {\n    return typeof fn === 'function' && _typeof(fn.signatures) === 'object';\n  }\n\n  function allowedInExpressions(name) {\n    return !unsafe.hasOwnProperty(name);\n  }\n\n  function factoryAllowedInExpressions(factory) {\n    return factory.path === undefined && !unsafe.hasOwnProperty(factory.name);\n  }\n\n  // namespaces and functions not available in the parser for safety reasons\n  var unsafe = {\n    'expression': true,\n    'type': true,\n    'docs': true,\n    'error': true,\n    'json': true,\n    'chain': true // chain method not supported. Note that there is a unit chain too.\n  };\n\n  return mathImport;\n}\n\nexports.math = true; // request access to the math namespace as 5th argument of the factory function\nexports.name = 'import';\nexports.factory = factory;\nexports.lazy = true;","'use strict';\n\n/**\n * Create a syntax error with the message:\n *     'Wrong number of arguments in function <fn> (<count> provided, <min>-<max> expected)'\n * @param {string} fn     Function name\n * @param {number} count  Actual argument count\n * @param {number} min    Minimum required argument count\n * @param {number} [max]  Maximum required argument count\n * @extends Error\n */\n\nfunction ArgumentsError(fn, count, min, max) {\n  if (!(this instanceof ArgumentsError)) {\n    throw new SyntaxError('Constructor must be called with the new operator');\n  }\n\n  this.fn = fn;\n  this.count = count;\n  this.min = min;\n  this.max = max;\n\n  this.message = 'Wrong number of arguments in function ' + fn + ' (' + count + ' provided, ' + min + (max !== undefined && max !== null ? '-' + max : '') + ' expected)';\n\n  this.stack = new Error().stack;\n}\n\nArgumentsError.prototype = new Error();\nArgumentsError.prototype.constructor = Error;\nArgumentsError.prototype.name = 'ArgumentsError';\nArgumentsError.prototype.isArgumentsError = true;\n\nmodule.exports = ArgumentsError;","'use strict';\n\nvar object = require('../../utils/object');\n\nfunction factory(type, config, load, typed, math) {\n  var MATRIX = ['Matrix', 'Array']; // valid values for option matrix\n  var NUMBER = ['number', 'BigNumber', 'Fraction']; // valid values for option number\n\n  /**\n   * Set configuration options for math.js, and get current options.\n   * Will emit a 'config' event, with arguments (curr, prev, changes).\n   *\n   * Syntax:\n   *\n   *     math.config(config: Object): Object\n   *\n   * Examples:\n   *\n   *     math.config().number                // outputs 'number'\n   *     math.eval('0.4')                    // outputs number 0.4\n   *     math.config({number: 'Fraction'})\n   *     math.eval('0.4')                    // outputs Fraction 2/5\n   *\n   * @param {Object} [options] Available options:\n   *                            {number} epsilon\n   *                              Minimum relative difference between two\n   *                              compared values, used by all comparison functions.\n   *                            {string} matrix\n   *                              A string 'Matrix' (default) or 'Array'.\n   *                            {string} number\n   *                              A string 'number' (default), 'BigNumber', or 'Fraction'\n   *                            {number} precision\n   *                              The number of significant digits for BigNumbers.\n   *                              Not applicable for Numbers.\n   *                            {string} parenthesis\n   *                              How to display parentheses in LaTeX and string\n   *                              output.\n   *                            {string} randomSeed\n   *                              Random seed for seeded pseudo random number generator.\n   *                              Set to null to randomly seed.\n   * @return {Object} Returns the current configuration\n   */\n  function _config(options) {\n    if (options) {\n      var prev = object.map(config, object.clone);\n\n      // validate some of the options\n      validateOption(options, 'matrix', MATRIX);\n      validateOption(options, 'number', NUMBER);\n\n      // merge options\n      object.deepExtend(config, options);\n\n      var curr = object.map(config, object.clone);\n\n      var changes = object.map(options, object.clone);\n\n      // emit 'config' event\n      math.emit('config', curr, prev, changes);\n\n      return curr;\n    } else {\n      return object.map(config, object.clone);\n    }\n  }\n\n  // attach the valid options to the function so they can be extended\n  _config.MATRIX = MATRIX;\n  _config.NUMBER = NUMBER;\n\n  return _config;\n}\n\n/**\n * Test whether an Array contains a specific item.\n * @param {Array.<string>} array\n * @param {string} item\n * @return {boolean}\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\n/**\n * Find a string in an array. Case insensitive search\n * @param {Array.<string>} array\n * @param {string} item\n * @return {number} Returns the index when found. Returns -1 when not found\n */\nfunction findIndex(array, item) {\n  return array.map(function (i) {\n    return i.toLowerCase();\n  }).indexOf(item.toLowerCase());\n}\n\n/**\n * Validate an option\n * @param {Object} options         Object with options\n * @param {string} name            Name of the option to validate\n * @param {Array.<string>} values  Array with valid values for this option\n */\nfunction validateOption(options, name, values) {\n  if (options[name] !== undefined && !contains(values, options[name])) {\n    var index = findIndex(values, options[name]);\n    if (index !== -1) {\n      // right value, wrong casing\n      // TODO: lower case values are deprecated since v3, remove this warning some day.\n      console.warn('Warning: Wrong casing for configuration option \"' + name + '\", should be \"' + values[index] + '\" instead of \"' + options[name] + '\".');\n\n      options[name] = values[index]; // change the option to the right casing\n    } else {\n      // unknown value\n      console.warn('Warning: Unknown value \"' + options[name] + '\" for configuration option \"' + name + '\". Available options: ' + values.map(JSON.stringify).join(', ') + '.');\n    }\n  }\n}\n\nexports.name = 'config';\nexports.math = true; // request the math namespace as fifth argument\nexports.factory = factory;","'use strict';\n\nvar string = require('../../utils/string');\n\nfunction factory(type, config, load, typed) {\n  /**\n   * Format a value of any type into a string.\n   *\n   * Syntax:\n   *\n   *    math.format(value)\n   *    math.format(value, options)\n   *    math.format(value, precision)\n   *    math.format(value, callback)\n   *\n   * Where:\n   *\n   *  - `value: *`\n   *    The value to be formatted\n   *  - `options: Object`\n   *    An object with formatting options. Available options:\n   *    - `notation: string`\n   *      Number notation. Choose from:\n   *      - 'fixed'\n   *        Always use regular number notation.\n   *        For example '123.40' and '14000000'\n   *      - 'exponential'\n   *        Always use exponential notation.\n   *        For example '1.234e+2' and '1.4e+7'\n   *      - 'engineering'\n   *        Always use engineering notation.\n   *        For example '123.4e+0' and '14.0e+6'\n   *      - 'auto' (default)\n   *        Regular number notation for numbers having an absolute value between\n   *        `lower` and `upper` bounds, and uses exponential notation elsewhere.\n   *        Lower bound is included, upper bound is excluded.\n   *        For example '123.4' and '1.4e7'.\n   *    - `precision: number`\n   *      A number between 0 and 16 to round the digits of the number. In case\n   *      of notations 'exponential', 'engineering', and 'auto', `precision`\n   *      defines the total number of significant digits returned.\n   *      In case of notation 'fixed', `precision` defines the number of\n   *      significant digits after the decimal point.\n   *      `precision` is undefined by default.\n   *    - `lowerExp: number`\n   *      Exponent determining the lower boundary for formatting a value with\n   *      an exponent when `notation='auto`. Default value is `-3`.\n   *    - `upperExp: number`\n   *      Exponent determining the upper boundary for formatting a value with\n   *      an exponent when `notation='auto`. Default value is `5`.\n   *    - `fraction: string`. Available values: 'ratio' (default) or 'decimal'.\n   *      For example `format(fraction(1, 3))` will output '1/3' when 'ratio' is\n   *      configured, and will output `0.(3)` when 'decimal' is configured.\n   * - `callback: function`\n   *   A custom formatting function, invoked for all numeric elements in `value`,\n   *   for example all elements of a matrix, or the real and imaginary\n   *   parts of a complex number. This callback can be used to override the\n   *   built-in numeric notation with any type of formatting. Function `callback`\n   *   is called with `value` as parameter and must return a string.\n   *\n   * When `value` is an Object:\n   *\n   * - When the object contains a property `format` being a function, this function\n   *   is invoked as `value.format(options)` and the result is returned.\n   * - When the object has its own `toString` method, this method is invoked\n   *   and the result is returned.\n   * - In other cases the function will loop over all object properties and\n   *   return JSON object notation like '{\"a\": 2, \"b\": 3}'.\n   *\n   * When value is a function:\n   *\n   * - When the function has a property `syntax`, it returns this\n   *   syntax description.\n   * - In other cases, a string `'function'` is returned.\n   *\n   * Examples:\n   *\n   *    math.format(6.4)                                        // returns '6.4'\n   *    math.format(1240000)                                    // returns '1.24e6'\n   *    math.format(1/3)                                        // returns '0.3333333333333333'\n   *    math.format(1/3, 3)                                     // returns '0.333'\n   *    math.format(21385, 2)                                   // returns '21000'\n   *    math.format(12e8, {notation: 'fixed'})                  // returns '1200000000'\n   *    math.format(2.3,  {notation: 'fixed', precision: 4})    // returns '2.3000'\n   *    math.format(52.8, {notation: 'exponential'})            // returns '5.28e+1'\n   *    math.format(12400,{notation: 'engineering'})            // returns '12.400e+3'\n   *    math.format(2000, {lowerExp: -2, upperExp: 2})          // returns '2e+3'\n   *\n   *    function formatCurrency(value) {\n   *      // return currency notation with two digits:\n   *      return '$' + value.toFixed(2)\n   *\n   *      // you could also use math.format inside the callback:\n   *      // return '$' + math.format(value, {notation: 'fixed', precision: 2})\n   *    }\n   *    math.format([2.1, 3, 0.016], formatCurrency}            // returns '[$2.10, $3.00, $0.02]'\n   *\n   * See also:\n   *\n   *    print\n   *\n   * @param {*} value                               Value to be stringified\n   * @param {Object | Function | number} [options]  Formatting options\n   * @return {string} The formatted value\n   */\n  var format = typed('format', {\n    'any': string.format,\n    'any, Object | function | number': string.format\n  });\n\n  format.toTex = undefined; // use default template\n\n  return format;\n}\n\nexports.name = 'format';\nexports.factory = factory;","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar formatNumber = require('./number').format;\nvar formatBigNumber = require('./bignumber/formatter').format;\nvar isBigNumber = require('./bignumber/isBigNumber');\n\n/**\n * Test whether value is a string\n * @param {*} value\n * @return {boolean} isString\n */\nexports.isString = function (value) {\n  return typeof value === 'string';\n};\n\n/**\n * Check if a text ends with a certain string.\n * @param {string} text\n * @param {string} search\n */\nexports.endsWith = function (text, search) {\n  var start = text.length - search.length;\n  var end = text.length;\n  return text.substring(start, end) === search;\n};\n\n/**\n * Format a value of any type into a string.\n *\n * Usage:\n *     math.format(value)\n *     math.format(value, precision)\n *\n * When value is a function:\n *\n * - When the function has a property `syntax`, it returns this\n *   syntax description.\n * - In other cases, a string `'function'` is returned.\n *\n * When `value` is an Object:\n *\n * - When the object contains a property `format` being a function, this\n *   function is invoked as `value.format(options)` and the result is returned.\n * - When the object has its own `toString` method, this method is invoked\n *   and the result is returned.\n * - In other cases the function will loop over all object properties and\n *   return JSON object notation like '{\"a\": 2, \"b\": 3}'.\n *\n * Example usage:\n *     math.format(2/7)                // '0.2857142857142857'\n *     math.format(math.pi, 3)         // '3.14'\n *     math.format(new Complex(2, 3))  // '2 + 3i'\n *     math.format('hello')            // '\"hello\"'\n *\n * @param {*} value             Value to be stringified\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @return {string} str\n */\nexports.format = function (value, options) {\n  if (typeof value === 'number') {\n    return formatNumber(value, options);\n  }\n\n  if (isBigNumber(value)) {\n    return formatBigNumber(value, options);\n  }\n\n  // note: we use unsafe duck-typing here to check for Fractions, this is\n  // ok here since we're only invoking toString or concatenating its values\n  if (looksLikeFraction(value)) {\n    if (!options || options.fraction !== 'decimal') {\n      // output as ratio, like '1/3'\n      return value.s * value.n + '/' + value.d;\n    } else {\n      // output as decimal, like '0.(3)'\n      return value.toString();\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return formatArray(value, options);\n  }\n\n  if (exports.isString(value)) {\n    return '\"' + value + '\"';\n  }\n\n  if (typeof value === 'function') {\n    return value.syntax ? String(value.syntax) : 'function';\n  }\n\n  if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n    if (typeof value.format === 'function') {\n      return value.format(options);\n    } else if (value && value.toString() !== {}.toString()) {\n      // this object has a non-native toString method, use that one\n      return value.toString();\n    } else {\n      var entries = [];\n\n      for (var key in value) {\n        if (value.hasOwnProperty(key)) {\n          entries.push('\"' + key + '\": ' + exports.format(value[key], options));\n        }\n      }\n\n      return '{' + entries.join(', ') + '}';\n    }\n  }\n\n  return String(value);\n};\n\n/**\n * Stringify a value into a string enclosed in double quotes.\n * Unescaped double quotes and backslashes inside the value are escaped.\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var text = String(value);\n  var escaped = '';\n  var i = 0;\n  while (i < text.length) {\n    var c = text.charAt(i);\n\n    if (c === '\\\\') {\n      escaped += c;\n      i++;\n\n      c = text.charAt(i);\n      if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) === -1) {\n        escaped += '\\\\'; // no valid escape character -> escape it\n      }\n      escaped += c;\n    } else if (c === '\"') {\n      escaped += '\\\\\"';\n    } else {\n      escaped += c;\n    }\n    i++;\n  }\n\n  return '\"' + escaped + '\"';\n};\n\n/**\n * Escape special HTML characters\n * @param {*} value\n * @return {string}\n */\nexports.escape = function (value) {\n  var text = String(value);\n  text = text.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\n  return text;\n};\n\n/**\n * Recursively format an n-dimensional matrix\n * Example output: \"[[1, 2], [3, 4]]\"\n * @param {Array} array\n * @param {Object | number | Function} [options]  Formatting options. See\n *                                                lib/utils/number:format for a\n *                                                description of the available\n *                                                options.\n * @returns {string} str\n */\nfunction formatArray(array, options) {\n  if (Array.isArray(array)) {\n    var str = '[';\n    var len = array.length;\n    for (var i = 0; i < len; i++) {\n      if (i !== 0) {\n        str += ', ';\n      }\n      str += formatArray(array[i], options);\n    }\n    str += ']';\n    return str;\n  } else {\n    return exports.format(array, options);\n  }\n}\n\n/**\n * Check whether a value looks like a Fraction (unsafe duck-type check)\n * @param {*} value\n * @return {boolean}\n */\nfunction looksLikeFraction(value) {\n  return value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.s === 'number' && typeof value.n === 'number' && typeof value.d === 'number' || false;\n}","'use strict';\n\nvar objectUtils = require('../object');\n\n/**\n * Convert a BigNumber to a formatted string representation.\n *\n * Syntax:\n *\n *    format(value)\n *    format(value, options)\n *    format(value, precision)\n *    format(value, fn)\n *\n * Where:\n *\n *    {number} value   The value to be formatted\n *    {Object} options An object with formatting options. Available options:\n *                     {string} notation\n *                         Number notation. Choose from:\n *                         'fixed'          Always use regular number notation.\n *                                          For example '123.40' and '14000000'\n *                         'exponential'    Always use exponential notation.\n *                                          For example '1.234e+2' and '1.4e+7'\n *                         'auto' (default) Regular number notation for numbers\n *                                          having an absolute value between\n *                                          `lower` and `upper` bounds, and uses\n *                                          exponential notation elsewhere.\n *                                          Lower bound is included, upper bound\n *                                          is excluded.\n *                                          For example '123.4' and '1.4e7'.\n *                     {number} precision   A number between 0 and 16 to round\n *                                          the digits of the number.\n *                                          In case of notations 'exponential',\n *                                          'engineering', and 'auto',\n *                                          `precision` defines the total\n *                                          number of significant digits returned.\n *                                          In case of notation 'fixed',\n *                                          `precision` defines the number of\n *                                          significant digits after the decimal\n *                                          point.\n *                                          `precision` is undefined by default.\n *                     {number} lowerExp    Exponent determining the lower boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `-3`.\n *                     {number} upperExp    Exponent determining the upper boundary\n *                                          for formatting a value with an exponent\n *                                          when `notation='auto`.\n *                                          Default value is `5`.\n *    {Function} fn    A custom formatting function. Can be used to override the\n *                     built-in notations. Function `fn` is called with `value` as\n *                     parameter and must return a string. Is useful for example to\n *                     format all values inside a matrix in a particular way.\n *\n * Examples:\n *\n *    format(6.4)                                        // '6.4'\n *    format(1240000)                                    // '1.24e6'\n *    format(1/3)                                        // '0.3333333333333333'\n *    format(1/3, 3)                                     // '0.333'\n *    format(21385, 2)                                   // '21000'\n *    format(12e8, {notation: 'fixed'})                  // returns '1200000000'\n *    format(2.3,    {notation: 'fixed', precision: 4})  // returns '2.3000'\n *    format(52.8,   {notation: 'exponential'})          // returns '5.28e+1'\n *    format(12400,  {notation: 'engineering'})          // returns '12.400e+3'\n *\n * @param {BigNumber} value\n * @param {Object | Function | number} [options]\n * @return {string} str The formatted value\n */\nexports.format = function (value, options) {\n  if (typeof options === 'function') {\n    // handle format(value, fn)\n    return options(value);\n  }\n\n  // handle special cases\n  if (!value.isFinite()) {\n    return value.isNaN() ? 'NaN' : value.gt(0) ? 'Infinity' : '-Infinity';\n  }\n\n  // default values for options\n  var notation = 'auto';\n  var precision = void 0;\n\n  if (options !== undefined) {\n    // determine notation from options\n    if (options.notation) {\n      notation = options.notation;\n    }\n\n    // determine precision from options\n    if (typeof options === 'number') {\n      precision = options;\n    } else if (options.precision) {\n      precision = options.precision;\n    }\n  }\n\n  // handle the various notations\n  switch (notation) {\n    case 'fixed':\n      return exports.toFixed(value, precision);\n\n    case 'exponential':\n      return exports.toExponential(value, precision);\n\n    case 'auto':\n      // TODO: clean up some day. Deprecated since: 2018-01-24\n      // @deprecated upper and lower are replaced with upperExp and lowerExp since v4.0.0\n      if (options && options.exponential && (options.exponential.lower !== undefined || options.exponential.upper !== undefined)) {\n        var fixedOptions = objectUtils.map(options, function (x) {\n          return x;\n        });\n        fixedOptions.exponential = undefined;\n        if (options.exponential.lower !== undefined) {\n          fixedOptions.lowerExp = Math.round(Math.log(options.exponential.lower) / Math.LN10);\n        }\n        if (options.exponential.upper !== undefined) {\n          fixedOptions.upperExp = Math.round(Math.log(options.exponential.upper) / Math.LN10);\n        }\n\n        console.warn('Deprecation warning: Formatting options exponential.lower and exponential.upper ' + '(minimum and maximum value) ' + 'are replaced with exponential.lowerExp and exponential.upperExp ' + '(minimum and maximum exponent) since version 4.0.0. ' + 'Replace ' + JSON.stringify(options) + ' with ' + JSON.stringify(fixedOptions));\n\n        return exports.format(value, fixedOptions);\n      }\n\n      // determine lower and upper bound for exponential notation.\n      // TODO: implement support for upper and lower to be BigNumbers themselves\n      var lowerExp = options && options.lowerExp !== undefined ? options.lowerExp : -3;\n      var upperExp = options && options.upperExp !== undefined ? options.upperExp : 5;\n\n      // handle special case zero\n      if (value.isZero()) return '0';\n\n      // determine whether or not to output exponential notation\n      var str = void 0;\n      var exp = value.logarithm();\n      if (exp.gte(lowerExp) && exp.lt(upperExp)) {\n        // normal number notation\n        str = value.toSignificantDigits(precision).toFixed();\n      } else {\n        // exponential notation\n        str = exports.toExponential(value, precision);\n      }\n\n      // remove trailing zeros after the decimal point\n      return str.replace(/((\\.\\d*?)(0+))($|e)/, function () {\n        var digits = arguments[2];\n        var e = arguments[4];\n        return digits !== '.' ? digits + e : e;\n      });\n\n    default:\n      throw new Error('Unknown notation \"' + notation + '\". ' + 'Choose \"auto\", \"exponential\", or \"fixed\".');\n  }\n};\n\n/**\n * Format a number in exponential notation. Like '1.23e+5', '2.3e+0', '3.500e-3'\n * @param {BigNumber} value\n * @param {number} [precision]  Number of digits in formatted output.\n *                              If not provided, the maximum available digits\n *                              is used.\n * @returns {string} str\n */\nexports.toExponential = function (value, precision) {\n  if (precision !== undefined) {\n    return value.toExponential(precision - 1); // Note the offset of one\n  } else {\n    return value.toExponential();\n  }\n};\n\n/**\n * Format a number with fixed notation.\n * @param {BigNumber} value\n * @param {number} [precision=undefined] Optional number of decimals after the\n *                                       decimal point. Undefined by default.\n */\nexports.toFixed = function (value, precision) {\n  return value.toFixed(precision);\n};"],"sourceRoot":""}